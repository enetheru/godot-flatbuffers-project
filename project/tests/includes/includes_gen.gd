# automatically generated by the FlatBuffers compiler, do not modify

# const relative = preload('res://tests/includes/relative_gen.gd')

static func GetRoot( _bytes : PackedByteArray ) -> RootTable:
	return GetRootTable( _bytes, _bytes.decode_u32(0) )

static func GetLocal( _bytes : PackedByteArray, _start : int  ) -> Local:
	if _bytes.is_empty(): return null
	var new_Local = Local.new()
	new_Local.start = _start
	new_Local.bytes = _bytes
	return new_Local


class Local extends FlatBuffer:
	enum vtable{
		VT_VAR_ = 4
	}

	func var__is_present() -> bool:
		return get_field_offset( vtable.VT_VAR_ )

	func var_() -> int:
		var foffset = get_field_offset( vtable.VT_VAR_ )
		if not foffset: return 0
		return bytes.decode_s32( start + foffset )


class LocalBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_var_( var_ : int ) -> void:
		fbb_.add_element_int_default( Local.vtable.VT_VAR_, var_, 0 )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		return o;


static func CreateLocal( _fbb : FlatBufferBuilder,
		var_ : int ) -> int :
	var builder = LocalBuilder.new( _fbb );
	builder.add_var_( var_ );
	return builder.finish();

static func GetRootTable( _bytes : PackedByteArray, _start : int = 0 ) -> RootTable:
	if _bytes.is_empty(): return null
	var new_RootTable = RootTable.new()
	new_RootTable.start = _start
	new_RootTable.bytes = _bytes
	return new_RootTable


class RootTable extends FlatBuffer:
	enum vtable{
		VT_FROM_LOCAL = 4,
		VT_FROM_RELATIVE = 6
	}

	func from_local_is_present() -> bool:
		return get_field_offset( vtable.VT_FROM_LOCAL )

	func from_local() -> Local:
		var field_start = get_field_start( vtable.VT_FROM_LOCAL )
		if not field_start: return null
		return parent.GetLocal( bytes, field_start )

	func from_relative_is_present() -> bool:
		return get_field_offset( vtable.VT_FROM_RELATIVE )

	func from_relative() -> relative.Relative:
		var field_start = get_field_start( vtable.VT_FROM_RELATIVE )
		if not field_start: return null
		return relative.GetRelative( bytes, field_start )


class RootTableBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_from_local( from_local_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_FROM_LOCAL, from_local_offset )

	func add_from_relative( from_relative_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_FROM_RELATIVE, from_relative_offset )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		return o;


static func CreateRootTable( _fbb : FlatBufferBuilder,
		from_local : int,
		from_relative : int ) -> int :
	var builder = RootTableBuilder.new( _fbb );
	builder.add_from_relative( from_relative );
	builder.add_from_local( from_local );
	return builder.finish();

