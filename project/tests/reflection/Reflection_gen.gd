# automatically generated by the FlatBuffers compiler, do not modify

static func GetRoot( _bytes : PackedByteArray ) -> Schema:
	return GetSchema( _bytes, _bytes.decode_u32(0) )

enum BaseType {
	NONE = 0,
	UTYPE = 1,
	BOOL = 2,
	BYTE = 3,
	UBYTE = 4,
	SHORT = 5,
	USHORT = 6,
	INT = 7,
	UINT = 8,
	LONG = 9,
	ULONG = 10,
	FLOAT = 11,
	DOUBLE = 12,
	STRING_ = 13,
	VECTOR = 14,
	OBJ = 15,
	UNION = 16,
	ARRAY_ = 17,
	MAXBASETYPE = 18
}

#/// New schema language features that are not supported by old code generators.
enum AdvancedFeatures {
	ADVANCEDARRAYFEATURES = 1,
	ADVANCEDUNIONFEATURES = 2,
	OPTIONALSCALARS = 4,
	DEFAULTVECTORSANDSTRINGS = 8
}

static func GetType( _bytes : PackedByteArray, _start : int  ) -> Type:
	if _bytes.is_empty(): return null
	var new_Type = Type.new()
	new_Type.start = _start
	new_Type.bytes = _bytes
	return new_Type


class Type extends FlatBuffer:
	enum vtable{
		VT_BASE_TYPE = 4,
		VT_ELEMENT = 6,
		VT_INDEX = 8,
		VT_FIXED_LENGTH = 10,
		VT_BASE_SIZE = 12,
		VT_ELEMENT_SIZE = 14
	}

	func base_type_is_present() -> bool:
		return get_field_offset( vtable.VT_BASE_TYPE )

	func base_type() -> BaseType:
		var foffset = get_field_offset( vtable.VT_BASE_TYPE )
		if not foffset: return 0 as BaseType
		return bytes.decode_s8( start + foffset ) as BaseType

	func element_is_present() -> bool:
		return get_field_offset( vtable.VT_ELEMENT )

	func element() -> BaseType:
		var foffset = get_field_offset( vtable.VT_ELEMENT )
		if not foffset: return 0 as BaseType
		return bytes.decode_s8( start + foffset ) as BaseType

	func index_is_present() -> bool:
		return get_field_offset( vtable.VT_INDEX )

	func index() -> int:
		var foffset = get_field_offset( vtable.VT_INDEX )
		if not foffset: return -1
		return bytes.decode_s32( start + foffset )

	func fixed_length_is_present() -> bool:
		return get_field_offset( vtable.VT_FIXED_LENGTH )

	func fixed_length() -> int:
		var foffset = get_field_offset( vtable.VT_FIXED_LENGTH )
		if not foffset: return 0
		return bytes.decode_u16( start + foffset )

	func base_size_is_present() -> bool:
		return get_field_offset( vtable.VT_BASE_SIZE )

	func base_size() -> int:
		var foffset = get_field_offset( vtable.VT_BASE_SIZE )
		if not foffset: return 4
		return bytes.decode_u32( start + foffset )

	func element_size_is_present() -> bool:
		return get_field_offset( vtable.VT_ELEMENT_SIZE )

	func element_size() -> int:
		var foffset = get_field_offset( vtable.VT_ELEMENT_SIZE )
		if not foffset: return 0
		return bytes.decode_u32( start + foffset )


class TypeBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_base_type( base_type : BaseType ) -> void:
		fbb_.add_element_byte_default( Type.vtable.VT_BASE_TYPE, base_type, 0 )

	func add_element( element : BaseType ) -> void:
		fbb_.add_element_byte_default( Type.vtable.VT_ELEMENT, element, 0 )

	func add_index( index : int ) -> void:
		fbb_.add_element_int_default( Type.vtable.VT_INDEX, index, -1 )

	func add_fixed_length( fixed_length : int ) -> void:
		fbb_.add_element_ushort_default( Type.vtable.VT_FIXED_LENGTH, fixed_length, 0 )

	func add_base_size( base_size : int ) -> void:
		fbb_.add_element_uint_default( Type.vtable.VT_BASE_SIZE, base_size, 4 )

	func add_element_size( element_size : int ) -> void:
		fbb_.add_element_uint_default( Type.vtable.VT_ELEMENT_SIZE, element_size, 0 )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		return o;


static func CreateType( _fbb : FlatBufferBuilder,
		base_type : BaseType,
		element : BaseType,
		index : int,
		fixed_length : int,
		base_size : int,
		element_size : int ) -> int :
	var builder = TypeBuilder.new( _fbb );
	builder.add_element_size( element_size );
	builder.add_base_size( base_size );
	builder.add_index( index );
	builder.add_fixed_length( fixed_length );
	builder.add_element( element );
	builder.add_base_type( base_type );
	return builder.finish();

static func GetKeyValue( _bytes : PackedByteArray, _start : int  ) -> KeyValue:
	if _bytes.is_empty(): return null
	var new_KeyValue = KeyValue.new()
	new_KeyValue.start = _start
	new_KeyValue.bytes = _bytes
	return new_KeyValue


class KeyValue extends FlatBuffer:
	enum vtable{
		VT_KEY = 4,
		VT_VALUE = 6
	}

	# key is required

	func key_is_present() -> bool:
		return get_field_offset( vtable.VT_KEY )

	func key() -> String:
		var field_start = get_field_start( vtable.VT_KEY )
		if not field_start: return ''
		return decode_String( field_start )

	func value_is_present() -> bool:
		return get_field_offset( vtable.VT_VALUE )

	func value() -> String:
		var field_start = get_field_start( vtable.VT_VALUE )
		if not field_start: return ''
		return decode_String( field_start )


class KeyValueBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_key( key_offset : int ) -> void:
		fbb_.add_offset( KeyValue.vtable.VT_KEY, key_offset )

	func add_value( value_offset : int ) -> void:
		fbb_.add_offset( KeyValue.vtable.VT_VALUE, value_offset )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		fbb_.Required(o, KeyValue.vtable.VT_KEY);
		return o;


static func CreateKeyValue( _fbb : FlatBufferBuilder,
		key : int,
		value : int ) -> int :
	var builder = KeyValueBuilder.new( _fbb );
	builder.add_value( value );
	builder.add_key( key );
	return builder.finish();

static func GetEnumVal( _bytes : PackedByteArray, _start : int  ) -> EnumVal:
	if _bytes.is_empty(): return null
	var new_EnumVal = EnumVal.new()
	new_EnumVal.start = _start
	new_EnumVal.bytes = _bytes
	return new_EnumVal


class EnumVal extends FlatBuffer:
	enum vtable{
		VT_NAME = 4,
		VT_VALUE = 6,
		VT_UNION_TYPE = 10,
		VT_DOCUMENTATION = 12,
		VT_ATTRIBUTES = 14
	}

	# name is required

	func name_is_present() -> bool:
		return get_field_offset( vtable.VT_NAME )

	func name() -> String:
		var field_start = get_field_start( vtable.VT_NAME )
		if not field_start: return ''
		return decode_String( field_start )

	func value_is_present() -> bool:
		return get_field_offset( vtable.VT_VALUE )

	func value() -> int:
		var foffset = get_field_offset( vtable.VT_VALUE )
		if not foffset: return 0
		return bytes.decode_s64( start + foffset )

	# field:'object' is deprecated

	func union_type_is_present() -> bool:
		return get_field_offset( vtable.VT_UNION_TYPE )

	func union_type() -> Type:
		var field_start = get_field_start( vtable.VT_UNION_TYPE )
		if not field_start: return null
		return parent.GetType( bytes, field_start )

	func documentation_is_present() -> bool:
		return get_field_offset( vtable.VT_DOCUMENTATION )

	func documentation_size() -> int:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func documentation() -> PackedStringArray:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedStringArray
		array.resize( array_size )
		for i in array_size:
			var idx = array_start + i * 4
			var element_start = idx + bytes.decode_u32( idx )
			array[i] = decode_String( element_start )
		return array

	func documentation_at( index : int ) -> String:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return ''
		array_start += 4
		var string_start = array_start + index * 4
		string_start += bytes.decode_u32( string_start )
		return decode_String( string_start )

	func attributes_is_present() -> bool:
		return get_field_offset( vtable.VT_ATTRIBUTES )

	func attributes_size() -> int:
		var array_start = get_field_start( vtable.VT_ATTRIBUTES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func attributes() -> Array:
		var array_start = get_field_start( vtable.VT_ATTRIBUTES )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array; array.resize( array_size )
		for i in array_size:
			var pos = array_start + i * 4
			array[i] = parent.GetKeyValue( bytes, pos + bytes.decode_u32( pos ) )
		return array


class EnumValBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_name( name_offset : int ) -> void:
		fbb_.add_offset( EnumVal.vtable.VT_NAME, name_offset )

	func add_value( value : int ) -> void:
		fbb_.add_element_long_default( EnumVal.vtable.VT_VALUE, value, 0 )

	func add_union_type( union_type_offset : int ) -> void:
		fbb_.add_offset( EnumVal.vtable.VT_UNION_TYPE, union_type_offset )

	func add_documentation( documentation_offset : int ) -> void:
		fbb_.add_offset( EnumVal.vtable.VT_DOCUMENTATION, documentation_offset )

	func add_attributes( attributes_offset : int ) -> void:
		fbb_.add_offset( EnumVal.vtable.VT_ATTRIBUTES, attributes_offset )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		fbb_.Required(o, EnumVal.vtable.VT_NAME);
		return o;


static func CreateEnumVal( _fbb : FlatBufferBuilder,
		name : int,
		value : int,
		union_type : int,
		documentation : int,
		attributes : int ) -> int :
	var builder = EnumValBuilder.new( _fbb );
	builder.add_value( value );
	builder.add_attributes( attributes );
	builder.add_documentation( documentation );
	builder.add_union_type( union_type );
	builder.add_name( name );
	return builder.finish();

static func GetEnum( _bytes : PackedByteArray, _start : int  ) -> Enum:
	if _bytes.is_empty(): return null
	var new_Enum = Enum.new()
	new_Enum.start = _start
	new_Enum.bytes = _bytes
	return new_Enum


class Enum extends FlatBuffer:
	enum vtable{
		VT_NAME = 4,
		VT_VALUES = 6,
		VT_IS_UNION = 8,
		VT_UNDERLYING_TYPE = 10,
		VT_ATTRIBUTES = 12,
		VT_DOCUMENTATION = 14,
		VT_DECLARATION_FILE = 16
	}

	# name is required

	func name_is_present() -> bool:
		return get_field_offset( vtable.VT_NAME )

	func name() -> String:
		var field_start = get_field_start( vtable.VT_NAME )
		if not field_start: return ''
		return decode_String( field_start )

	# values is required

	func values_is_present() -> bool:
		return get_field_offset( vtable.VT_VALUES )

	func values_size() -> int:
		var array_start = get_field_start( vtable.VT_VALUES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func values() -> Array:
		var array_start = get_field_start( vtable.VT_VALUES )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array; array.resize( array_size )
		for i in array_size:
			var pos = array_start + i * 4
			array[i] = parent.GetEnumVal( bytes, pos + bytes.decode_u32( pos ) )
		return array

	func is_union_is_present() -> bool:
		return get_field_offset( vtable.VT_IS_UNION )

	func is_union() -> bool:
		var foffset = get_field_offset( vtable.VT_IS_UNION )
		if not foffset: return 0
		return bytes.decode_u8( start + foffset )

	# underlying_type is required

	func underlying_type_is_present() -> bool:
		return get_field_offset( vtable.VT_UNDERLYING_TYPE )

	func underlying_type() -> Type:
		var field_start = get_field_start( vtable.VT_UNDERLYING_TYPE )
		if not field_start: return null
		return parent.GetType( bytes, field_start )

	func attributes_is_present() -> bool:
		return get_field_offset( vtable.VT_ATTRIBUTES )

	func attributes_size() -> int:
		var array_start = get_field_start( vtable.VT_ATTRIBUTES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func attributes() -> Array:
		var array_start = get_field_start( vtable.VT_ATTRIBUTES )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array; array.resize( array_size )
		for i in array_size:
			var pos = array_start + i * 4
			array[i] = parent.GetKeyValue( bytes, pos + bytes.decode_u32( pos ) )
		return array

	func documentation_is_present() -> bool:
		return get_field_offset( vtable.VT_DOCUMENTATION )

	func documentation_size() -> int:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func documentation() -> PackedStringArray:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedStringArray
		array.resize( array_size )
		for i in array_size:
			var idx = array_start + i * 4
			var element_start = idx + bytes.decode_u32( idx )
			array[i] = decode_String( element_start )
		return array

	func documentation_at( index : int ) -> String:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return ''
		array_start += 4
		var string_start = array_start + index * 4
		string_start += bytes.decode_u32( string_start )
		return decode_String( string_start )

	func declaration_file_is_present() -> bool:
		return get_field_offset( vtable.VT_DECLARATION_FILE )

	func declaration_file() -> String:
		var field_start = get_field_start( vtable.VT_DECLARATION_FILE )
		if not field_start: return ''
		return decode_String( field_start )


class EnumBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_name( name_offset : int ) -> void:
		fbb_.add_offset( Enum.vtable.VT_NAME, name_offset )

	func add_values( values_offset : int ) -> void:
		fbb_.add_offset( Enum.vtable.VT_VALUES, values_offset )

	func add_is_union( is_union : bool ) -> void:
		fbb_.add_element_bool_default( Enum.vtable.VT_IS_UNION, is_union, 0 )

	func add_underlying_type( underlying_type_offset : int ) -> void:
		fbb_.add_offset( Enum.vtable.VT_UNDERLYING_TYPE, underlying_type_offset )

	func add_attributes( attributes_offset : int ) -> void:
		fbb_.add_offset( Enum.vtable.VT_ATTRIBUTES, attributes_offset )

	func add_documentation( documentation_offset : int ) -> void:
		fbb_.add_offset( Enum.vtable.VT_DOCUMENTATION, documentation_offset )

	func add_declaration_file( declaration_file_offset : int ) -> void:
		fbb_.add_offset( Enum.vtable.VT_DECLARATION_FILE, declaration_file_offset )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		fbb_.Required(o, Enum.vtable.VT_NAME);
		fbb_.Required(o, Enum.vtable.VT_VALUES);
		fbb_.Required(o, Enum.vtable.VT_UNDERLYING_TYPE);
		return o;


static func CreateEnum( _fbb : FlatBufferBuilder,
		name : int,
		values : int,
		is_union : bool,
		underlying_type : int,
		attributes : int,
		documentation : int,
		declaration_file : int ) -> int :
	var builder = EnumBuilder.new( _fbb );
	builder.add_declaration_file( declaration_file );
	builder.add_documentation( documentation );
	builder.add_attributes( attributes );
	builder.add_underlying_type( underlying_type );
	builder.add_values( values );
	builder.add_name( name );
	builder.add_is_union( is_union );
	return builder.finish();

static func GetField( _bytes : PackedByteArray, _start : int  ) -> Field:
	if _bytes.is_empty(): return null
	var new_Field = Field.new()
	new_Field.start = _start
	new_Field.bytes = _bytes
	return new_Field


class Field extends FlatBuffer:
	enum vtable{
		VT_NAME = 4,
		VT_TYPE = 6,
		VT_ID = 8,
		VT_OFFSET = 10,
		VT_DEFAULT_INTEGER = 12,
		VT_DEFAULT_REAL = 14,
		VT_DEPRECATED = 16,
		VT_REQUIRED = 18,
		VT_KEY = 20,
		VT_ATTRIBUTES = 22,
		VT_DOCUMENTATION = 24,
		VT_OPTIONAL = 26,
		VT_PADDING = 28
	}

	# name is required

	func name_is_present() -> bool:
		return get_field_offset( vtable.VT_NAME )

	func name() -> String:
		var field_start = get_field_start( vtable.VT_NAME )
		if not field_start: return ''
		return decode_String( field_start )

	# type is required

	func type_is_present() -> bool:
		return get_field_offset( vtable.VT_TYPE )

	func type() -> Type:
		var field_start = get_field_start( vtable.VT_TYPE )
		if not field_start: return null
		return parent.GetType( bytes, field_start )

	func id_is_present() -> bool:
		return get_field_offset( vtable.VT_ID )

	func id() -> int:
		var foffset = get_field_offset( vtable.VT_ID )
		if not foffset: return 0
		return bytes.decode_u16( start + foffset )

	func offset_is_present() -> bool:
		return get_field_offset( vtable.VT_OFFSET )

	func offset() -> int:
		var foffset = get_field_offset( vtable.VT_OFFSET )
		if not foffset: return 0
		return bytes.decode_u16( start + foffset )

	func default_integer_is_present() -> bool:
		return get_field_offset( vtable.VT_DEFAULT_INTEGER )

	func default_integer() -> int:
		var foffset = get_field_offset( vtable.VT_DEFAULT_INTEGER )
		if not foffset: return 0
		return bytes.decode_s64( start + foffset )

	func default_real_is_present() -> bool:
		return get_field_offset( vtable.VT_DEFAULT_REAL )

	func default_real() -> float:
		var foffset = get_field_offset( vtable.VT_DEFAULT_REAL )
		if not foffset: return 0.0
		return bytes.decode_double( start + foffset )

	func deprecated_is_present() -> bool:
		return get_field_offset( vtable.VT_DEPRECATED )

	func deprecated() -> bool:
		var foffset = get_field_offset( vtable.VT_DEPRECATED )
		if not foffset: return 0
		return bytes.decode_u8( start + foffset )

	func required_is_present() -> bool:
		return get_field_offset( vtable.VT_REQUIRED )

	func required() -> bool:
		var foffset = get_field_offset( vtable.VT_REQUIRED )
		if not foffset: return 0
		return bytes.decode_u8( start + foffset )

	func key_is_present() -> bool:
		return get_field_offset( vtable.VT_KEY )

	func key() -> bool:
		var foffset = get_field_offset( vtable.VT_KEY )
		if not foffset: return 0
		return bytes.decode_u8( start + foffset )

	func attributes_is_present() -> bool:
		return get_field_offset( vtable.VT_ATTRIBUTES )

	func attributes_size() -> int:
		var array_start = get_field_start( vtable.VT_ATTRIBUTES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func attributes() -> Array:
		var array_start = get_field_start( vtable.VT_ATTRIBUTES )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array; array.resize( array_size )
		for i in array_size:
			var pos = array_start + i * 4
			array[i] = parent.GetKeyValue( bytes, pos + bytes.decode_u32( pos ) )
		return array

	func documentation_is_present() -> bool:
		return get_field_offset( vtable.VT_DOCUMENTATION )

	func documentation_size() -> int:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func documentation() -> PackedStringArray:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedStringArray
		array.resize( array_size )
		for i in array_size:
			var idx = array_start + i * 4
			var element_start = idx + bytes.decode_u32( idx )
			array[i] = decode_String( element_start )
		return array

	func documentation_at( index : int ) -> String:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return ''
		array_start += 4
		var string_start = array_start + index * 4
		string_start += bytes.decode_u32( string_start )
		return decode_String( string_start )

	func optional_is_present() -> bool:
		return get_field_offset( vtable.VT_OPTIONAL )

	func optional() -> bool:
		var foffset = get_field_offset( vtable.VT_OPTIONAL )
		if not foffset: return 0
		return bytes.decode_u8( start + foffset )

	func padding_is_present() -> bool:
		return get_field_offset( vtable.VT_PADDING )

	func padding() -> int:
		var foffset = get_field_offset( vtable.VT_PADDING )
		if not foffset: return 0
		return bytes.decode_u16( start + foffset )


class FieldBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_name( name_offset : int ) -> void:
		fbb_.add_offset( Field.vtable.VT_NAME, name_offset )

	func add_type( type_offset : int ) -> void:
		fbb_.add_offset( Field.vtable.VT_TYPE, type_offset )

	func add_id( id : int ) -> void:
		fbb_.add_element_ushort_default( Field.vtable.VT_ID, id, 0 )

	func add_offset( offset : int ) -> void:
		fbb_.add_element_ushort_default( Field.vtable.VT_OFFSET, offset, 0 )

	func add_default_integer( default_integer : int ) -> void:
		fbb_.add_element_long_default( Field.vtable.VT_DEFAULT_INTEGER, default_integer, 0 )

	func add_default_real( default_real : float ) -> void:
		fbb_.add_element_double_default( Field.vtable.VT_DEFAULT_REAL, default_real, 0.0 )

	func add_deprecated( deprecated : bool ) -> void:
		fbb_.add_element_bool_default( Field.vtable.VT_DEPRECATED, deprecated, 0 )

	func add_required( required : bool ) -> void:
		fbb_.add_element_bool_default( Field.vtable.VT_REQUIRED, required, 0 )

	func add_key( key : bool ) -> void:
		fbb_.add_element_bool_default( Field.vtable.VT_KEY, key, 0 )

	func add_attributes( attributes_offset : int ) -> void:
		fbb_.add_offset( Field.vtable.VT_ATTRIBUTES, attributes_offset )

	func add_documentation( documentation_offset : int ) -> void:
		fbb_.add_offset( Field.vtable.VT_DOCUMENTATION, documentation_offset )

	func add_optional( optional : bool ) -> void:
		fbb_.add_element_bool_default( Field.vtable.VT_OPTIONAL, optional, 0 )

	func add_padding( padding : int ) -> void:
		fbb_.add_element_ushort_default( Field.vtable.VT_PADDING, padding, 0 )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		fbb_.Required(o, Field.vtable.VT_NAME);
		fbb_.Required(o, Field.vtable.VT_TYPE);
		return o;


static func CreateField( _fbb : FlatBufferBuilder,
		name : int,
		type : int,
		id : int,
		offset : int,
		default_integer : int,
		default_real : float,
		deprecated : bool,
		required : bool,
		key : bool,
		attributes : int,
		documentation : int,
		optional : bool,
		padding : int ) -> int :
	var builder = FieldBuilder.new( _fbb );
	builder.add_default_real( default_real );
	builder.add_default_integer( default_integer );
	builder.add_documentation( documentation );
	builder.add_attributes( attributes );
	builder.add_type( type );
	builder.add_name( name );
	builder.add_padding( padding );
	builder.add_offset( offset );
	builder.add_id( id );
	builder.add_optional( optional );
	builder.add_key( key );
	builder.add_required( required );
	builder.add_deprecated( deprecated );
	return builder.finish();

static func GetObject_( _bytes : PackedByteArray, _start : int  ) -> Object_:
	if _bytes.is_empty(): return null
	var new_Object_ = Object_.new()
	new_Object_.start = _start
	new_Object_.bytes = _bytes
	return new_Object_


class Object_ extends FlatBuffer:
	enum vtable{
		VT_NAME = 4,
		VT_FIELDS = 6,
		VT_IS_STRUCT = 8,
		VT_MINALIGN = 10,
		VT_BYTESIZE = 12,
		VT_ATTRIBUTES = 14,
		VT_DOCUMENTATION = 16,
		VT_DECLARATION_FILE = 18
	}

	# name is required

	func name_is_present() -> bool:
		return get_field_offset( vtable.VT_NAME )

	func name() -> String:
		var field_start = get_field_start( vtable.VT_NAME )
		if not field_start: return ''
		return decode_String( field_start )

	# fields is required

	func fields_is_present() -> bool:
		return get_field_offset( vtable.VT_FIELDS )

	func fields_size() -> int:
		var array_start = get_field_start( vtable.VT_FIELDS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fields() -> Array:
		var array_start = get_field_start( vtable.VT_FIELDS )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array; array.resize( array_size )
		for i in array_size:
			var pos = array_start + i * 4
			array[i] = parent.GetField( bytes, pos + bytes.decode_u32( pos ) )
		return array

	func is_struct_is_present() -> bool:
		return get_field_offset( vtable.VT_IS_STRUCT )

	func is_struct() -> bool:
		var foffset = get_field_offset( vtable.VT_IS_STRUCT )
		if not foffset: return 0
		return bytes.decode_u8( start + foffset )

	func minalign_is_present() -> bool:
		return get_field_offset( vtable.VT_MINALIGN )

	func minalign() -> int:
		var foffset = get_field_offset( vtable.VT_MINALIGN )
		if not foffset: return 0
		return bytes.decode_s32( start + foffset )

	func bytesize_is_present() -> bool:
		return get_field_offset( vtable.VT_BYTESIZE )

	func bytesize() -> int:
		var foffset = get_field_offset( vtable.VT_BYTESIZE )
		if not foffset: return 0
		return bytes.decode_s32( start + foffset )

	func attributes_is_present() -> bool:
		return get_field_offset( vtable.VT_ATTRIBUTES )

	func attributes_size() -> int:
		var array_start = get_field_start( vtable.VT_ATTRIBUTES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func attributes() -> Array:
		var array_start = get_field_start( vtable.VT_ATTRIBUTES )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array; array.resize( array_size )
		for i in array_size:
			var pos = array_start + i * 4
			array[i] = parent.GetKeyValue( bytes, pos + bytes.decode_u32( pos ) )
		return array

	func documentation_is_present() -> bool:
		return get_field_offset( vtable.VT_DOCUMENTATION )

	func documentation_size() -> int:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func documentation() -> PackedStringArray:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedStringArray
		array.resize( array_size )
		for i in array_size:
			var idx = array_start + i * 4
			var element_start = idx + bytes.decode_u32( idx )
			array[i] = decode_String( element_start )
		return array

	func documentation_at( index : int ) -> String:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return ''
		array_start += 4
		var string_start = array_start + index * 4
		string_start += bytes.decode_u32( string_start )
		return decode_String( string_start )

	func declaration_file_is_present() -> bool:
		return get_field_offset( vtable.VT_DECLARATION_FILE )

	func declaration_file() -> String:
		var field_start = get_field_start( vtable.VT_DECLARATION_FILE )
		if not field_start: return ''
		return decode_String( field_start )


class Object_Builder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_name( name_offset : int ) -> void:
		fbb_.add_offset( Object_.vtable.VT_NAME, name_offset )

	func add_fields( fields_offset : int ) -> void:
		fbb_.add_offset( Object_.vtable.VT_FIELDS, fields_offset )

	func add_is_struct( is_struct : bool ) -> void:
		fbb_.add_element_bool_default( Object_.vtable.VT_IS_STRUCT, is_struct, 0 )

	func add_minalign( minalign : int ) -> void:
		fbb_.add_element_int_default( Object_.vtable.VT_MINALIGN, minalign, 0 )

	func add_bytesize( bytesize : int ) -> void:
		fbb_.add_element_int_default( Object_.vtable.VT_BYTESIZE, bytesize, 0 )

	func add_attributes( attributes_offset : int ) -> void:
		fbb_.add_offset( Object_.vtable.VT_ATTRIBUTES, attributes_offset )

	func add_documentation( documentation_offset : int ) -> void:
		fbb_.add_offset( Object_.vtable.VT_DOCUMENTATION, documentation_offset )

	func add_declaration_file( declaration_file_offset : int ) -> void:
		fbb_.add_offset( Object_.vtable.VT_DECLARATION_FILE, declaration_file_offset )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		fbb_.Required(o, Object_.vtable.VT_NAME);
		fbb_.Required(o, Object_.vtable.VT_FIELDS);
		return o;


static func CreateObject_( _fbb : FlatBufferBuilder,
		name : int,
		fields : int,
		is_struct : bool,
		minalign : int,
		bytesize : int,
		attributes : int,
		documentation : int,
		declaration_file : int ) -> int :
	var builder = Object_Builder.new( _fbb );
	builder.add_declaration_file( declaration_file );
	builder.add_documentation( documentation );
	builder.add_attributes( attributes );
	builder.add_bytesize( bytesize );
	builder.add_minalign( minalign );
	builder.add_fields( fields );
	builder.add_name( name );
	builder.add_is_struct( is_struct );
	return builder.finish();

static func GetRPCCall( _bytes : PackedByteArray, _start : int  ) -> RPCCall:
	if _bytes.is_empty(): return null
	var new_RPCCall = RPCCall.new()
	new_RPCCall.start = _start
	new_RPCCall.bytes = _bytes
	return new_RPCCall


class RPCCall extends FlatBuffer:
	enum vtable{
		VT_NAME = 4,
		VT_REQUEST = 6,
		VT_RESPONSE = 8,
		VT_ATTRIBUTES = 10,
		VT_DOCUMENTATION = 12
	}

	# name is required

	func name_is_present() -> bool:
		return get_field_offset( vtable.VT_NAME )

	func name() -> String:
		var field_start = get_field_start( vtable.VT_NAME )
		if not field_start: return ''
		return decode_String( field_start )

	# request is required

	func request_is_present() -> bool:
		return get_field_offset( vtable.VT_REQUEST )

	func request() -> Object_:
		var field_start = get_field_start( vtable.VT_REQUEST )
		if not field_start: return null
		return parent.GetObject_( bytes, field_start )

	# response is required

	func response_is_present() -> bool:
		return get_field_offset( vtable.VT_RESPONSE )

	func response() -> Object_:
		var field_start = get_field_start( vtable.VT_RESPONSE )
		if not field_start: return null
		return parent.GetObject_( bytes, field_start )

	func attributes_is_present() -> bool:
		return get_field_offset( vtable.VT_ATTRIBUTES )

	func attributes_size() -> int:
		var array_start = get_field_start( vtable.VT_ATTRIBUTES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func attributes() -> Array:
		var array_start = get_field_start( vtable.VT_ATTRIBUTES )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array; array.resize( array_size )
		for i in array_size:
			var pos = array_start + i * 4
			array[i] = parent.GetKeyValue( bytes, pos + bytes.decode_u32( pos ) )
		return array

	func documentation_is_present() -> bool:
		return get_field_offset( vtable.VT_DOCUMENTATION )

	func documentation_size() -> int:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func documentation() -> PackedStringArray:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedStringArray
		array.resize( array_size )
		for i in array_size:
			var idx = array_start + i * 4
			var element_start = idx + bytes.decode_u32( idx )
			array[i] = decode_String( element_start )
		return array

	func documentation_at( index : int ) -> String:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return ''
		array_start += 4
		var string_start = array_start + index * 4
		string_start += bytes.decode_u32( string_start )
		return decode_String( string_start )


class RPCCallBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_name( name_offset : int ) -> void:
		fbb_.add_offset( RPCCall.vtable.VT_NAME, name_offset )

	func add_request( request_offset : int ) -> void:
		fbb_.add_offset( RPCCall.vtable.VT_REQUEST, request_offset )

	func add_response( response_offset : int ) -> void:
		fbb_.add_offset( RPCCall.vtable.VT_RESPONSE, response_offset )

	func add_attributes( attributes_offset : int ) -> void:
		fbb_.add_offset( RPCCall.vtable.VT_ATTRIBUTES, attributes_offset )

	func add_documentation( documentation_offset : int ) -> void:
		fbb_.add_offset( RPCCall.vtable.VT_DOCUMENTATION, documentation_offset )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		fbb_.Required(o, RPCCall.vtable.VT_NAME);
		fbb_.Required(o, RPCCall.vtable.VT_REQUEST);
		fbb_.Required(o, RPCCall.vtable.VT_RESPONSE);
		return o;


static func CreateRPCCall( _fbb : FlatBufferBuilder,
		name : int,
		request : int,
		response : int,
		attributes : int,
		documentation : int ) -> int :
	var builder = RPCCallBuilder.new( _fbb );
	builder.add_documentation( documentation );
	builder.add_attributes( attributes );
	builder.add_response( response );
	builder.add_request( request );
	builder.add_name( name );
	return builder.finish();

static func GetService( _bytes : PackedByteArray, _start : int  ) -> Service:
	if _bytes.is_empty(): return null
	var new_Service = Service.new()
	new_Service.start = _start
	new_Service.bytes = _bytes
	return new_Service


class Service extends FlatBuffer:
	enum vtable{
		VT_NAME = 4,
		VT_CALLS = 6,
		VT_ATTRIBUTES = 8,
		VT_DOCUMENTATION = 10,
		VT_DECLARATION_FILE = 12
	}

	# name is required

	func name_is_present() -> bool:
		return get_field_offset( vtable.VT_NAME )

	func name() -> String:
		var field_start = get_field_start( vtable.VT_NAME )
		if not field_start: return ''
		return decode_String( field_start )

	func calls_is_present() -> bool:
		return get_field_offset( vtable.VT_CALLS )

	func calls_size() -> int:
		var array_start = get_field_start( vtable.VT_CALLS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func calls() -> Array:
		var array_start = get_field_start( vtable.VT_CALLS )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array; array.resize( array_size )
		for i in array_size:
			var pos = array_start + i * 4
			array[i] = parent.GetRPCCall( bytes, pos + bytes.decode_u32( pos ) )
		return array

	func attributes_is_present() -> bool:
		return get_field_offset( vtable.VT_ATTRIBUTES )

	func attributes_size() -> int:
		var array_start = get_field_start( vtable.VT_ATTRIBUTES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func attributes() -> Array:
		var array_start = get_field_start( vtable.VT_ATTRIBUTES )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array; array.resize( array_size )
		for i in array_size:
			var pos = array_start + i * 4
			array[i] = parent.GetKeyValue( bytes, pos + bytes.decode_u32( pos ) )
		return array

	func documentation_is_present() -> bool:
		return get_field_offset( vtable.VT_DOCUMENTATION )

	func documentation_size() -> int:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func documentation() -> PackedStringArray:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedStringArray
		array.resize( array_size )
		for i in array_size:
			var idx = array_start + i * 4
			var element_start = idx + bytes.decode_u32( idx )
			array[i] = decode_String( element_start )
		return array

	func documentation_at( index : int ) -> String:
		var array_start = get_field_start( vtable.VT_DOCUMENTATION )
		if not array_start: return ''
		array_start += 4
		var string_start = array_start + index * 4
		string_start += bytes.decode_u32( string_start )
		return decode_String( string_start )

	func declaration_file_is_present() -> bool:
		return get_field_offset( vtable.VT_DECLARATION_FILE )

	func declaration_file() -> String:
		var field_start = get_field_start( vtable.VT_DECLARATION_FILE )
		if not field_start: return ''
		return decode_String( field_start )


class ServiceBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_name( name_offset : int ) -> void:
		fbb_.add_offset( Service.vtable.VT_NAME, name_offset )

	func add_calls( calls_offset : int ) -> void:
		fbb_.add_offset( Service.vtable.VT_CALLS, calls_offset )

	func add_attributes( attributes_offset : int ) -> void:
		fbb_.add_offset( Service.vtable.VT_ATTRIBUTES, attributes_offset )

	func add_documentation( documentation_offset : int ) -> void:
		fbb_.add_offset( Service.vtable.VT_DOCUMENTATION, documentation_offset )

	func add_declaration_file( declaration_file_offset : int ) -> void:
		fbb_.add_offset( Service.vtable.VT_DECLARATION_FILE, declaration_file_offset )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		fbb_.Required(o, Service.vtable.VT_NAME);
		return o;


static func CreateService( _fbb : FlatBufferBuilder,
		name : int,
		calls : int,
		attributes : int,
		documentation : int,
		declaration_file : int ) -> int :
	var builder = ServiceBuilder.new( _fbb );
	builder.add_declaration_file( declaration_file );
	builder.add_documentation( documentation );
	builder.add_attributes( attributes );
	builder.add_calls( calls );
	builder.add_name( name );
	return builder.finish();

#/// File specific information.
#/// Symbols declared within a file may be recovered by iterating over all
#/// symbols and examining the `declaration_file` field.
static func GetSchemaFile( _bytes : PackedByteArray, _start : int  ) -> SchemaFile:
	if _bytes.is_empty(): return null
	var new_SchemaFile = SchemaFile.new()
	new_SchemaFile.start = _start
	new_SchemaFile.bytes = _bytes
	return new_SchemaFile


class SchemaFile extends FlatBuffer:
	enum vtable{
		VT_FILENAME = 4,
		VT_INCLUDED_FILENAMES = 6
	}

	# filename is required

	func filename_is_present() -> bool:
		return get_field_offset( vtable.VT_FILENAME )

	func filename() -> String:
		var field_start = get_field_start( vtable.VT_FILENAME )
		if not field_start: return ''
		return decode_String( field_start )

	func included_filenames_is_present() -> bool:
		return get_field_offset( vtable.VT_INCLUDED_FILENAMES )

	func included_filenames_size() -> int:
		var array_start = get_field_start( vtable.VT_INCLUDED_FILENAMES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func included_filenames() -> PackedStringArray:
		var array_start = get_field_start( vtable.VT_INCLUDED_FILENAMES )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedStringArray
		array.resize( array_size )
		for i in array_size:
			var idx = array_start + i * 4
			var element_start = idx + bytes.decode_u32( idx )
			array[i] = decode_String( element_start )
		return array

	func included_filenames_at( index : int ) -> String:
		var array_start = get_field_start( vtable.VT_INCLUDED_FILENAMES )
		if not array_start: return ''
		array_start += 4
		var string_start = array_start + index * 4
		string_start += bytes.decode_u32( string_start )
		return decode_String( string_start )


class SchemaFileBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_filename( filename_offset : int ) -> void:
		fbb_.add_offset( SchemaFile.vtable.VT_FILENAME, filename_offset )

	func add_included_filenames( included_filenames_offset : int ) -> void:
		fbb_.add_offset( SchemaFile.vtable.VT_INCLUDED_FILENAMES, included_filenames_offset )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		fbb_.Required(o, SchemaFile.vtable.VT_FILENAME);
		return o;


static func CreateSchemaFile( _fbb : FlatBufferBuilder,
		filename : int,
		included_filenames : int ) -> int :
	var builder = SchemaFileBuilder.new( _fbb );
	builder.add_included_filenames( included_filenames );
	builder.add_filename( filename );
	return builder.finish();

static func GetSchema( _bytes : PackedByteArray, _start : int = 0 ) -> Schema:
	if _bytes.is_empty(): return null
	var new_Schema = Schema.new()
	new_Schema.start = _start
	new_Schema.bytes = _bytes
	return new_Schema


class Schema extends FlatBuffer:
	enum vtable{
		VT_OBJECTS = 4,
		VT_ENUMS = 6,
		VT_FILE_IDENT = 8,
		VT_FILE_EXT = 10,
		VT_ROOT_TABLE = 12,
		VT_SERVICES = 14,
		VT_ADVANCED_FEATURES = 16,
		VT_FBS_FILES = 18
	}

	# objects is required

	func objects_is_present() -> bool:
		return get_field_offset( vtable.VT_OBJECTS )

	func objects_size() -> int:
		var array_start = get_field_start( vtable.VT_OBJECTS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func objects() -> Array:
		var array_start = get_field_start( vtable.VT_OBJECTS )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array; array.resize( array_size )
		for i in array_size:
			var pos = array_start + i * 4
			array[i] = parent.GetObject_( bytes, pos + bytes.decode_u32( pos ) )
		return array

	# enums is required

	func enums_is_present() -> bool:
		return get_field_offset( vtable.VT_ENUMS )

	func enums_size() -> int:
		var array_start = get_field_start( vtable.VT_ENUMS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func enums() -> Array:
		var array_start = get_field_start( vtable.VT_ENUMS )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array; array.resize( array_size )
		for i in array_size:
			var pos = array_start + i * 4
			array[i] = parent.GetEnum( bytes, pos + bytes.decode_u32( pos ) )
		return array

	func file_ident_is_present() -> bool:
		return get_field_offset( vtable.VT_FILE_IDENT )

	func file_ident() -> String:
		var field_start = get_field_start( vtable.VT_FILE_IDENT )
		if not field_start: return ''
		return decode_String( field_start )

	func file_ext_is_present() -> bool:
		return get_field_offset( vtable.VT_FILE_EXT )

	func file_ext() -> String:
		var field_start = get_field_start( vtable.VT_FILE_EXT )
		if not field_start: return ''
		return decode_String( field_start )

	func root_table_is_present() -> bool:
		return get_field_offset( vtable.VT_ROOT_TABLE )

	func root_table() -> Object_:
		var field_start = get_field_start( vtable.VT_ROOT_TABLE )
		if not field_start: return null
		return parent.GetObject_( bytes, field_start )

	func services_is_present() -> bool:
		return get_field_offset( vtable.VT_SERVICES )

	func services_size() -> int:
		var array_start = get_field_start( vtable.VT_SERVICES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func services() -> Array:
		var array_start = get_field_start( vtable.VT_SERVICES )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array; array.resize( array_size )
		for i in array_size:
			var pos = array_start + i * 4
			array[i] = parent.GetService( bytes, pos + bytes.decode_u32( pos ) )
		return array

	func advanced_features_is_present() -> bool:
		return get_field_offset( vtable.VT_ADVANCED_FEATURES )

	func advanced_features() -> AdvancedFeatures:
		var foffset = get_field_offset( vtable.VT_ADVANCED_FEATURES )
		if not foffset: return 0 as AdvancedFeatures
		return bytes.decode_u64( start + foffset ) as AdvancedFeatures

	func fbs_files_is_present() -> bool:
		return get_field_offset( vtable.VT_FBS_FILES )

	func fbs_files_size() -> int:
		var array_start = get_field_start( vtable.VT_FBS_FILES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fbs_files() -> Array:
		var array_start = get_field_start( vtable.VT_FBS_FILES )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array; array.resize( array_size )
		for i in array_size:
			var pos = array_start + i * 4
			array[i] = parent.GetSchemaFile( bytes, pos + bytes.decode_u32( pos ) )
		return array


class SchemaBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_objects( objects_offset : int ) -> void:
		fbb_.add_offset( Schema.vtable.VT_OBJECTS, objects_offset )

	func add_enums( enums_offset : int ) -> void:
		fbb_.add_offset( Schema.vtable.VT_ENUMS, enums_offset )

	func add_file_ident( file_ident_offset : int ) -> void:
		fbb_.add_offset( Schema.vtable.VT_FILE_IDENT, file_ident_offset )

	func add_file_ext( file_ext_offset : int ) -> void:
		fbb_.add_offset( Schema.vtable.VT_FILE_EXT, file_ext_offset )

	func add_root_table( root_table_offset : int ) -> void:
		fbb_.add_offset( Schema.vtable.VT_ROOT_TABLE, root_table_offset )

	func add_services( services_offset : int ) -> void:
		fbb_.add_offset( Schema.vtable.VT_SERVICES, services_offset )

	func add_advanced_features( advanced_features : AdvancedFeatures ) -> void:
		fbb_.add_element_ulong_default( Schema.vtable.VT_ADVANCED_FEATURES, advanced_features, 0 )

	func add_fbs_files( fbs_files_offset : int ) -> void:
		fbb_.add_offset( Schema.vtable.VT_FBS_FILES, fbs_files_offset )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		fbb_.Required(o, Schema.vtable.VT_OBJECTS);
		fbb_.Required(o, Schema.vtable.VT_ENUMS);
		return o;


static func CreateSchema( _fbb : FlatBufferBuilder,
		objects : int,
		enums : int,
		file_ident : int,
		file_ext : int,
		root_table : int,
		services : int,
		advanced_features : AdvancedFeatures,
		fbs_files : int ) -> int :
	var builder = SchemaBuilder.new( _fbb );
	builder.add_advanced_features( advanced_features );
	builder.add_fbs_files( fbs_files );
	builder.add_services( services );
	builder.add_root_table( root_table );
	builder.add_file_ext( file_ext );
	builder.add_file_ident( file_ident );
	builder.add_enums( enums );
	builder.add_objects( objects );
	return builder.finish();

