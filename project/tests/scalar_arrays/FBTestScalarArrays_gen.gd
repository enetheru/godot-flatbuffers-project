# automatically generated by the FlatBuffers compiler, do not modify

static func GetRoot( _bytes : PackedByteArray ) -> RootTable:
	return GetRootTable( _bytes, _bytes.decode_u32(0) )

static func GetRootTable( _bytes : PackedByteArray, _start : int = 0 ) -> RootTable:
	if _bytes.is_empty(): return null
	var new_RootTable = RootTable.new()
	new_RootTable.start = _start
	new_RootTable.bytes = _bytes
	return new_RootTable


class RootTable extends FlatBuffer:
	enum vtable{
		VT_BYTES_ = 4,
		VT_UBYTES = 6,
		VT_SHORTS = 8,
		VT_USHORTS = 10,
		VT_INTS = 12,
		VT_UINTS = 14,
		VT_INT64S = 16,
		VT_UINT64S = 18,
		VT_FLOATS = 20,
		VT_DOUBLES = 22
	}

	func bytes__is_present() -> bool:
		return get_field_offset( vtable.VT_BYTES_ )

	func bytes__size() -> int:
		var array_start = get_field_start( vtable.VT_BYTES_ )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func bytes_() -> Array:
		var array_start = get_field_start( vtable.VT_BYTES_ )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array = []
		array.resize( array_size )
		for i in array_size:
			array[i] = bytes.decode_s8( array_start + i * 1)
		return array

	func bytes__at( index : int ) -> int:
		var array_start = get_field_start( vtable.VT_BYTES_ )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_s8( array_start + index * 1)

	func ubytes_is_present() -> bool:
		return get_field_offset( vtable.VT_UBYTES )

	func ubytes_size() -> int:
		var array_start = get_field_start( vtable.VT_UBYTES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func ubytes() -> PackedByteArray:
		var array_start = get_field_start( vtable.VT_UBYTES )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		return bytes.slice( array_start, array_start + array_size )

	func ubytes_at( index : int ) -> int:
		var array_start = get_field_start( vtable.VT_UBYTES )
		if not array_start: return 0
		array_start += 4
		return bytes[array_start + index]

	func shorts_is_present() -> bool:
		return get_field_offset( vtable.VT_SHORTS )

	func shorts_size() -> int:
		var array_start = get_field_start( vtable.VT_SHORTS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func shorts() -> Array:
		var array_start = get_field_start( vtable.VT_SHORTS )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array = []
		array.resize( array_size )
		for i in array_size:
			array[i] = bytes.decode_s16( array_start + i * 2)
		return array

	func shorts_at( index : int ) -> int:
		var array_start = get_field_start( vtable.VT_SHORTS )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_s16( array_start + index * 2)

	func ushorts_is_present() -> bool:
		return get_field_offset( vtable.VT_USHORTS )

	func ushorts_size() -> int:
		var array_start = get_field_start( vtable.VT_USHORTS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func ushorts() -> Array:
		var array_start = get_field_start( vtable.VT_USHORTS )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array = []
		array.resize( array_size )
		for i in array_size:
			array[i] = bytes.decode_u16( array_start + i * 2)
		return array

	func ushorts_at( index : int ) -> int:
		var array_start = get_field_start( vtable.VT_USHORTS )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_u16( array_start + index * 2)

	func ints_is_present() -> bool:
		return get_field_offset( vtable.VT_INTS )

	func ints_size() -> int:
		var array_start = get_field_start( vtable.VT_INTS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func ints() -> PackedInt32Array:
		var array_start = get_field_start( vtable.VT_INTS )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array_end = array_start + array_size * 4
		return bytes.slice( array_start, array_end ).to_int32_array()

	func ints_at( index : int ) -> int:
		var array_start = get_field_start( vtable.VT_INTS )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_s32( array_start + index * 4)

	func uints_is_present() -> bool:
		return get_field_offset( vtable.VT_UINTS )

	func uints_size() -> int:
		var array_start = get_field_start( vtable.VT_UINTS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func uints() -> Array:
		var array_start = get_field_start( vtable.VT_UINTS )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array = []
		array.resize( array_size )
		for i in array_size:
			array[i] = bytes.decode_u32( array_start + i * 4)
		return array

	func uints_at( index : int ) -> int:
		var array_start = get_field_start( vtable.VT_UINTS )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_u32( array_start + index * 4)

	func int64s_is_present() -> bool:
		return get_field_offset( vtable.VT_INT64S )

	func int64s_size() -> int:
		var array_start = get_field_start( vtable.VT_INT64S )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func int64s() -> PackedInt64Array:
		var array_start = get_field_start( vtable.VT_INT64S )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array_end = array_start + array_size * 8
		return bytes.slice( array_start, array_end ).to_int64_array()

	func int64s_at( index : int ) -> int:
		var array_start = get_field_start( vtable.VT_INT64S )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_s64( array_start + index * 8)

	func uint64s_is_present() -> bool:
		return get_field_offset( vtable.VT_UINT64S )

	func uint64s_size() -> int:
		var array_start = get_field_start( vtable.VT_UINT64S )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func uint64s() -> Array:
		var array_start = get_field_start( vtable.VT_UINT64S )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array = []
		array.resize( array_size )
		for i in array_size:
			array[i] = bytes.decode_u64( array_start + i * 8)
		return array

	func uint64s_at( index : int ) -> int:
		var array_start = get_field_start( vtable.VT_UINT64S )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_u64( array_start + index * 8)

	func floats_is_present() -> bool:
		return get_field_offset( vtable.VT_FLOATS )

	func floats_size() -> int:
		var array_start = get_field_start( vtable.VT_FLOATS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func floats() -> PackedFloat32Array:
		var array_start = get_field_start( vtable.VT_FLOATS )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array_end = array_start + array_size * 4
		return bytes.slice( array_start, array_end ).to_float32_array()

	func floats_at( index : int ) -> float:
		var array_start = get_field_start( vtable.VT_FLOATS )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_float( array_start + index * 4)

	func doubles_is_present() -> bool:
		return get_field_offset( vtable.VT_DOUBLES )

	func doubles_size() -> int:
		var array_start = get_field_start( vtable.VT_DOUBLES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func doubles() -> PackedFloat64Array:
		var array_start = get_field_start( vtable.VT_DOUBLES )
		if not array_start: return []
		var array_size = bytes.decode_u32( array_start )
		array_start += 4
		var array_end = array_start + array_size * 8
		return bytes.slice( array_start, array_end ).to_float64_array()

	func doubles_at( index : int ) -> float:
		var array_start = get_field_start( vtable.VT_DOUBLES )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_double( array_start + index * 8)


class RootTableBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_bytes_( bytes__offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_BYTES_, bytes__offset )

	func add_ubytes( ubytes_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_UBYTES, ubytes_offset )

	func add_shorts( shorts_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_SHORTS, shorts_offset )

	func add_ushorts( ushorts_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_USHORTS, ushorts_offset )

	func add_ints( ints_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_INTS, ints_offset )

	func add_uints( uints_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_UINTS, uints_offset )

	func add_int64s( int64s_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_INT64S, int64s_offset )

	func add_uint64s( uint64s_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_UINT64S, uint64s_offset )

	func add_floats( floats_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_FLOATS, floats_offset )

	func add_doubles( doubles_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_DOUBLES, doubles_offset )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		return o;


static func CreateRootTable( _fbb : FlatBufferBuilder,
		bytes_ : int,
		ubytes : int,
		shorts : int,
		ushorts : int,
		ints : int,
		uints : int,
		int64s : int,
		uint64s : int,
		floats : int,
		doubles : int ) -> int :
	var builder = RootTableBuilder.new( _fbb );
	builder.add_doubles( doubles );
	builder.add_floats( floats );
	builder.add_uint64s( uint64s );
	builder.add_int64s( int64s );
	builder.add_uints( uints );
	builder.add_ints( ints );
	builder.add_ushorts( ushorts );
	builder.add_shorts( shorts );
	builder.add_ubytes( ubytes );
	builder.add_bytes_( bytes_ );
	return builder.finish();

