# automatically generated by the FlatBuffers compiler, do not modify

# To maintain reference counted PackedByteArray the gdextension type for data
# must be Variant, which triggers these two notices
@warning_ignore_start('unsafe_method_access')
@warning_ignore_start('unsafe_call_argument')

static func get_root( _bytes : PackedByteArray ) -> RootTable:
	return get_RootTable( _bytes, _bytes.decode_u32(0) )

static func create_Item(
		_id : int,
		_pos : Vector3 ) -> Item :
	var val : Item = Item.new()
	val.pos = _pos;
	val.id = _id;
	return val

class Item extends FlatBuffer:
	const size : int = 24

	func _init( bytes_ : PackedByteArray = [], start_ : int = 0) -> void:
		if bytes_.is_empty(): 
			bytes = PackedByteArray()
			bytes.resize( size )
		else:
			assert(start_ + size <= bytes_.size())
			bytes = bytes_; start = start_

	# [================[ id ]================]
	var id : int :
		get(): return bytes.decode_u64(start + 0)
		set(v): bytes.encode_u64(start + 0, v)

	# [================[ pos ]================]
	var pos : Vector3 :
		get(): return decode_Vector3(start + 8)
		set(v): encode_Vector3(start + 8, v)


static func create_Bag(
		_item : Item,
		_items : Array ) -> Bag :
	var val : Bag = Bag.new()
	val.items = _items;
	val.item = _item;
	return val

class Bag extends FlatBuffer:
	const _test_schema_schema = preload( 'test_schema_generated.gd' )

	const size : int = 72

	func _init( bytes_ : PackedByteArray = [], start_ : int = 0) -> void:
		if bytes_.is_empty(): 
			bytes = PackedByteArray()
			bytes.resize( size )
		else:
			assert(start_ + size <= bytes_.size())
			bytes = bytes_; start = start_

	# [================[ item ]================]
	var item : Item :
		get(): return _test_schema_schema.get_Item(bytes, start + 0)
		set(v): overwrite_bytes(v.bytes, v.start, start + 0, v.size)

	# [================[ items ]================]
	var items : Array :
		get = get_items, set = set_items

	func get_items() -> Array:
		# TODO Struct Type
		return []

	func set_items( _v : Array ):
		# TODO Struct Type
		pass

	func at_items( idx : int ) -> _test_schema_schema.Item:
		assert( idx < 2)
		return _test_schema_schema.get_Item( bytes, 24 + idx * 24)


class RootTable extends FlatBuffer:
	const _test_schema_schema = preload( 'test_schema_generated.gd' )

	enum vtable{
		VT_CONTAINER = 4
	}

	func _init( bytes_ : PackedByteArray = [], start_ : int = 0) -> void:
		bytes = bytes_; start = start_

	# Presence Functions
	func container_is_present() -> bool:
		return get_field_offset( vtable.VT_CONTAINER )

	# [================[ container ]================]
	func container() -> Bag:
		var field_offset : int = get_field_offset( vtable.VT_CONTAINER )
		if not field_offset: return null
		return _test_schema_schema.get_Bag( bytes, start + field_offset )


class RootTableBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ) -> void:
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_container( container : Bag ) -> void:
		fbb_.add_bytes( RootTable.vtable.VT_CONTAINER, container.bytes ) 

	func finish() -> int:
		var end : int = fbb_.end_table( start_ )
		var o : int = end
		return o;


static func get_Item( _bytes : PackedByteArray, _start : int = 0 ) -> Item:
	assert(not _bytes.is_empty())
	return Item.new(_bytes, _start)

static func get_Bag( _bytes : PackedByteArray, _start : int = 0 ) -> Bag:
	assert(not _bytes.is_empty())
	return Bag.new(_bytes, _start)

static func get_RootTable( _bytes : PackedByteArray, _start : int = 0 ) -> RootTable:
	assert(not _bytes.is_empty())
	return RootTable.new(_bytes, _start)

static func create_RootTable( _fbb : FlatBufferBuilder,
		container : Bag ) -> int :
	var builder : RootTableBuilder = RootTableBuilder.new( _fbb );
	builder.add_container( container );
	return builder.finish();

