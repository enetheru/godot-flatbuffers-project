# automatically generated by the FlatBuffers compiler, do not modify

# To maintain reference counted PackedByteArray the gdextension type for data
# must be Variant, which triggers these two notices
@warning_ignore_start('unsafe_method_access')
@warning_ignore_start('unsafe_call_argument')

static func get_root( _bytes : PackedByteArray ) -> RootTable:
	return get_RootTable( _bytes, _bytes.decode_u32(0) )

class RootTable extends FlatBuffer:
	enum vtable{
		VT_F_BOOL = 4,
		VT_F_BYTE = 6,
		VT_F_UBYTE = 8,
		VT_F_SHORT = 10,
		VT_F_USHORT = 12,
		VT_F_INT = 14,
		VT_F_UINT = 16,
		VT_F_LONG = 18,
		VT_F_ULONG = 20,
		VT_F_FLOAT = 22,
		VT_F_DOUBLE = 24
	}

	func _init( bytes_ : PackedByteArray = [], start_ : int = 0) -> void:
		bytes = bytes_; start = start_

	# Presence Functions
	func f_bool_is_present() -> bool:
		return get_field_offset( vtable.VT_F_BOOL )

	func f_byte_is_present() -> bool:
		return get_field_offset( vtable.VT_F_BYTE )

	func f_ubyte_is_present() -> bool:
		return get_field_offset( vtable.VT_F_UBYTE )

	func f_short_is_present() -> bool:
		return get_field_offset( vtable.VT_F_SHORT )

	func f_ushort_is_present() -> bool:
		return get_field_offset( vtable.VT_F_USHORT )

	func f_int_is_present() -> bool:
		return get_field_offset( vtable.VT_F_INT )

	func f_uint_is_present() -> bool:
		return get_field_offset( vtable.VT_F_UINT )

	func f_long_is_present() -> bool:
		return get_field_offset( vtable.VT_F_LONG )

	func f_ulong_is_present() -> bool:
		return get_field_offset( vtable.VT_F_ULONG )

	func f_float_is_present() -> bool:
		return get_field_offset( vtable.VT_F_FLOAT )

	func f_double_is_present() -> bool:
		return get_field_offset( vtable.VT_F_DOUBLE )

	# [================[ f_bool ]================]
	func f_bool() -> int:
		var foffset : int = get_field_offset( vtable.VT_F_BOOL )
		if not foffset: return 0
		return bytes.decode_u8( start + foffset )

	# [================[ f_byte ]================]
	func f_byte() -> bool:
		var foffset : int = get_field_offset( vtable.VT_F_BYTE )
		if not foffset: return 0
		return bytes.decode_s8( start + foffset )

	# [================[ f_ubyte ]================]
	func f_ubyte() -> int:
		var foffset : int = get_field_offset( vtable.VT_F_UBYTE )
		if not foffset: return 0
		return bytes.decode_u8( start + foffset )

	# [================[ f_short ]================]
	func f_short() -> int:
		var foffset : int = get_field_offset( vtable.VT_F_SHORT )
		if not foffset: return 0
		return bytes.decode_s16( start + foffset )

	# [================[ f_ushort ]================]
	func f_ushort() -> int:
		var foffset : int = get_field_offset( vtable.VT_F_USHORT )
		if not foffset: return 0
		return bytes.decode_u16( start + foffset )

	# [================[ f_int ]================]
	func f_int() -> int:
		var foffset : int = get_field_offset( vtable.VT_F_INT )
		if not foffset: return 0
		return bytes.decode_s32( start + foffset )

	# [================[ f_uint ]================]
	func f_uint() -> int:
		var foffset : int = get_field_offset( vtable.VT_F_UINT )
		if not foffset: return 0
		return bytes.decode_u32( start + foffset )

	# [================[ f_long ]================]
	func f_long() -> int:
		var foffset : int = get_field_offset( vtable.VT_F_LONG )
		if not foffset: return 0
		return bytes.decode_s64( start + foffset )

	# [================[ f_ulong ]================]
	func f_ulong() -> int:
		var foffset : int = get_field_offset( vtable.VT_F_ULONG )
		if not foffset: return 0
		return bytes.decode_u64( start + foffset )

	# [================[ f_float ]================]
	func f_float() -> float:
		var foffset : int = get_field_offset( vtable.VT_F_FLOAT )
		if not foffset: return 0.0
		return bytes.decode_float( start + foffset )

	# [================[ f_double ]================]
	func f_double() -> float:
		var foffset : int = get_field_offset( vtable.VT_F_DOUBLE )
		if not foffset: return 0.0
		return bytes.decode_double( start + foffset )


class RootTableBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ) -> void:
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_f_bool( f_bool : int ) -> void:
		fbb_.add_element_bool_default( RootTable.vtable.VT_F_BOOL, f_bool, 0 )

	func add_f_byte( f_byte : bool ) -> void:
		fbb_.add_element_byte_default( RootTable.vtable.VT_F_BYTE, f_byte, 0 )

	func add_f_ubyte( f_ubyte : int ) -> void:
		fbb_.add_element_ubyte_default( RootTable.vtable.VT_F_UBYTE, f_ubyte, 0 )

	func add_f_short( f_short : int ) -> void:
		fbb_.add_element_short_default( RootTable.vtable.VT_F_SHORT, f_short, 0 )

	func add_f_ushort( f_ushort : int ) -> void:
		fbb_.add_element_ushort_default( RootTable.vtable.VT_F_USHORT, f_ushort, 0 )

	func add_f_int( f_int : int ) -> void:
		fbb_.add_element_int_default( RootTable.vtable.VT_F_INT, f_int, 0 )

	func add_f_uint( f_uint : int ) -> void:
		fbb_.add_element_uint_default( RootTable.vtable.VT_F_UINT, f_uint, 0 )

	func add_f_long( f_long : int ) -> void:
		fbb_.add_element_long_default( RootTable.vtable.VT_F_LONG, f_long, 0 )

	func add_f_ulong( f_ulong : int ) -> void:
		fbb_.add_element_ulong_default( RootTable.vtable.VT_F_ULONG, f_ulong, 0 )

	func add_f_float( f_float : float ) -> void:
		fbb_.add_element_float_default( RootTable.vtable.VT_F_FLOAT, f_float, 0.0 )

	func add_f_double( f_double : float ) -> void:
		fbb_.add_element_double_default( RootTable.vtable.VT_F_DOUBLE, f_double, 0.0 )

	func finish() -> int:
		var end : int = fbb_.end_table( start_ )
		var o : int = end
		return o;


static func get_RootTable( _bytes : PackedByteArray, _start : int = 0 ) -> RootTable:
	assert(not _bytes.is_empty())
	return RootTable.new(_bytes, _start)

static func create_RootTable( _fbb : FlatBufferBuilder,
		f_bool : int,
		f_byte : bool,
		f_ubyte : int,
		f_short : int,
		f_ushort : int,
		f_int : int,
		f_uint : int,
		f_long : int,
		f_ulong : int,
		f_float : float,
		f_double : float ) -> int :
	var builder : RootTableBuilder = RootTableBuilder.new( _fbb );
	builder.add_f_double( f_double );
	builder.add_f_ulong( f_ulong );
	builder.add_f_long( f_long );
	builder.add_f_float( f_float );
	builder.add_f_uint( f_uint );
	builder.add_f_int( f_int );
	builder.add_f_ushort( f_ushort );
	builder.add_f_short( f_short );
	builder.add_f_ubyte( f_ubyte );
	builder.add_f_byte( f_byte );
	builder.add_f_bool( f_bool );
	return builder.finish();

