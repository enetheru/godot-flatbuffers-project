# automatically generated by the FlatBuffers compiler, do not modify

# To maintain reference counted PackedByteArray the gdextension type for data
# must be Variant, which can trigger the 'unsafe method access' warning if enabled
@warning_ignore_start('unsafe_method_access')

static func get_root( _bytes : PackedByteArray ) -> TestTable:
	return get_TestTable( _bytes, _bytes.decode_u32(0) )

class TestTable extends FlatBuffer:
	# failed to find include for Vector3i using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Vector2i using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Color using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Vector4i using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Quaternion using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Vector2 using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Vector3 using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Rect2 using: addons/gdflatbuffers/godot.fbs
	# failed to find include for AABB using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Basis using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Plane using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Transform3D using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Vector4 using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Projection using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Rect2i using: addons/gdflatbuffers/godot.fbs
	# failed to find include for Transform2D using: addons/gdflatbuffers/godot.fbs

	enum vtable{
		VT_FBOOL = 4,
		VT_FINT8 = 6,
		VT_FINT16 = 8,
		VT_FUINT16 = 10,
		VT_FUINT32 = 12,
		VT_FINT64 = 14,
		VT_FUINT8 = 16,
		VT_FINT32 = 18,
		VT_FUINT64 = 20,
		VT_FFLOAT32 = 22,
		VT_FFLOAT64 = 24,
		VT_FSTRING = 26,
		VT_FCOLOR = 28,
		VT_FVECTOR2 = 30,
		VT_FVECTOR3 = 32,
		VT_FVECTOR4 = 34,
		VT_FAABB = 36,
		VT_FBASIS = 38,
		VT_FPLANE = 40,
		VT_FPROJECTION = 42,
		VT_FQUATERNION = 44,
		VT_FRECT2 = 46,
		VT_FRECT2I = 48,
		VT_FTRANSFORM2D = 50,
		VT_FTRANSFORM3D = 52,
		VT_FVECTOR2I = 54,
		VT_FVECTOR3I = 56,
		VT_FVECTOR4I = 58
	}

	# Presence Functions
	func fbool_is_present() -> bool:
		return get_field_offset( vtable.VT_FBOOL )

	func fint8_is_present() -> bool:
		return get_field_offset( vtable.VT_FINT8 )

	func fint16_is_present() -> bool:
		return get_field_offset( vtable.VT_FINT16 )

	func fuint16_is_present() -> bool:
		return get_field_offset( vtable.VT_FUINT16 )

	func fuint32_is_present() -> bool:
		return get_field_offset( vtable.VT_FUINT32 )

	func fint64_is_present() -> bool:
		return get_field_offset( vtable.VT_FINT64 )

	func fuint8_is_present() -> bool:
		return get_field_offset( vtable.VT_FUINT8 )

	func fint32_is_present() -> bool:
		return get_field_offset( vtable.VT_FINT32 )

	func fuint64_is_present() -> bool:
		return get_field_offset( vtable.VT_FUINT64 )

	func ffloat32_is_present() -> bool:
		return get_field_offset( vtable.VT_FFLOAT32 )

	func ffloat64_is_present() -> bool:
		return get_field_offset( vtable.VT_FFLOAT64 )

	func fstring_is_present() -> bool:
		return get_field_offset( vtable.VT_FSTRING )

	func fcolor_is_present() -> bool:
		return get_field_offset( vtable.VT_FCOLOR )

	func fvector2_is_present() -> bool:
		return get_field_offset( vtable.VT_FVECTOR2 )

	func fvector3_is_present() -> bool:
		return get_field_offset( vtable.VT_FVECTOR3 )

	func fvector4_is_present() -> bool:
		return get_field_offset( vtable.VT_FVECTOR4 )

	func faabb_is_present() -> bool:
		return get_field_offset( vtable.VT_FAABB )

	func fbasis_is_present() -> bool:
		return get_field_offset( vtable.VT_FBASIS )

	func fplane_is_present() -> bool:
		return get_field_offset( vtable.VT_FPLANE )

	func fprojection_is_present() -> bool:
		return get_field_offset( vtable.VT_FPROJECTION )

	func fquaternion_is_present() -> bool:
		return get_field_offset( vtable.VT_FQUATERNION )

	func frect2_is_present() -> bool:
		return get_field_offset( vtable.VT_FRECT2 )

	func frect2i_is_present() -> bool:
		return get_field_offset( vtable.VT_FRECT2I )

	func ftransform2d_is_present() -> bool:
		return get_field_offset( vtable.VT_FTRANSFORM2D )

	func ftransform3d_is_present() -> bool:
		return get_field_offset( vtable.VT_FTRANSFORM3D )

	func fvector2i_is_present() -> bool:
		return get_field_offset( vtable.VT_FVECTOR2I )

	func fvector3i_is_present() -> bool:
		return get_field_offset( vtable.VT_FVECTOR3I )

	func fvector4i_is_present() -> bool:
		return get_field_offset( vtable.VT_FVECTOR4I )

	# Accessor Functions
	# [================[ fbool ]================]
	func fbool_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FBOOL )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fbool() -> Array:
		var array_start : int = get_field_start( vtable.VT_FBOOL )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		return bytes.slice( array_start, array_start + array_size )

	func fbool_at( index : int ) -> bool:
		var array_start : int = get_field_start( vtable.VT_FBOOL )
		if not array_start: return 0
		array_start += 4
		return bytes[array_start + index]

	# [================[ fint8 ]================]
	func fint8_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FINT8 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fint8() -> Array:
		var array_start : int = get_field_start( vtable.VT_FINT8 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = bytes.decode_s8( array_start + i * 1)
		# To return packed array types, the scalar elements have to be of an appropriate type.
		return array

	func fint8_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_FINT8 )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_s8( array_start + index * 1)

	# [================[ fint16 ]================]
	func fint16_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FINT16 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fint16() -> Array:
		var array_start : int = get_field_start( vtable.VT_FINT16 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = bytes.decode_s16( array_start + i * 2)
		# To return packed array types, the scalar elements have to be of an appropriate type.
		return array

	func fint16_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_FINT16 )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_s16( array_start + index * 2)

	# [================[ fuint16 ]================]
	func fuint16_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FUINT16 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fuint16() -> Array:
		var array_start : int = get_field_start( vtable.VT_FUINT16 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = bytes.decode_u16( array_start + i * 2)
		# To return packed array types, the scalar elements have to be of an appropriate type.
		return array

	func fuint16_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_FUINT16 )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_u16( array_start + index * 2)

	# [================[ fuint32 ]================]
	func fuint32_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FUINT32 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fuint32() -> Array:
		var array_start : int = get_field_start( vtable.VT_FUINT32 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = bytes.decode_u32( array_start + i * 4)
		# To return packed array types, the scalar elements have to be of an appropriate type.
		return array

	func fuint32_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_FUINT32 )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_u32( array_start + index * 4)

	# [================[ fint64 ]================]
	func fint64_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FINT64 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fint64() -> PackedInt64Array:
		var array_start : int = get_field_start( vtable.VT_FINT64 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array_end : int = array_start + array_size * 8
		return bytes.slice( array_start, array_end ).to_int64_array()

	func fint64_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_FINT64 )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_s64( array_start + index * 8)

	# [================[ fuint8 ]================]
	func fuint8_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FUINT8 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fuint8() -> PackedByteArray:
		var array_start : int = get_field_start( vtable.VT_FUINT8 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		return bytes.slice( array_start, array_start + array_size )

	func fuint8_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_FUINT8 )
		if not array_start: return 0
		array_start += 4
		return bytes[array_start + index]

	# [================[ fint32 ]================]
	func fint32_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FINT32 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fint32() -> PackedInt32Array:
		var array_start : int = get_field_start( vtable.VT_FINT32 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array_end : int = array_start + array_size * 4
		return bytes.slice( array_start, array_end ).to_int32_array()

	func fint32_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_FINT32 )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_s32( array_start + index * 4)

	# [================[ fuint64 ]================]
	func fuint64_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FUINT64 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fuint64() -> Array:
		var array_start : int = get_field_start( vtable.VT_FUINT64 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = bytes.decode_u64( array_start + i * 8)
		# To return packed array types, the scalar elements have to be of an appropriate type.
		return array

	func fuint64_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_FUINT64 )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_u64( array_start + index * 8)

	# [================[ ffloat32 ]================]
	func ffloat32_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FFLOAT32 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func ffloat32() -> PackedFloat32Array:
		var array_start : int = get_field_start( vtable.VT_FFLOAT32 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array_end : int = array_start + array_size * 4
		return bytes.slice( array_start, array_end ).to_float32_array()

	func ffloat32_at( index : int ) -> float:
		var array_start : int = get_field_start( vtable.VT_FFLOAT32 )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_float( array_start + index * 4)

	# [================[ ffloat64 ]================]
	func ffloat64_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FFLOAT64 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func ffloat64() -> PackedFloat64Array:
		var array_start : int = get_field_start( vtable.VT_FFLOAT64 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array_end : int = array_start + array_size * 8
		return bytes.slice( array_start, array_end ).to_float64_array()

	func ffloat64_at( index : int ) -> float:
		var array_start : int = get_field_start( vtable.VT_FFLOAT64 )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_double( array_start + index * 8)

	# [================[ fstring ]================]
	func fstring_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FSTRING )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fstring() -> PackedStringArray:
		var array_start : int = get_field_start( vtable.VT_FSTRING )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedStringArray
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			var idx : int = array_start + i * 4
			var element_start : int = idx + bytes.decode_u32( idx )
			array[i] = decode_String( element_start )
		return array

	func fstring_at( index : int ) -> String:
		var array_start : int = get_field_start( vtable.VT_FSTRING )
		if not array_start: return ''
		array_start += 4
		var string_start : int = array_start + index * 4
		string_start += bytes.decode_u32( string_start )
		return decode_String( string_start )

	# [================[ fcolor ]================]
	func fcolor_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FCOLOR )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fcolor() -> PackedColorArray:
		var array_start : int = get_field_start( vtable.VT_FCOLOR )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedColorArray
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Color( array_start + i * 16)
		return array

	# TODO GenFieldVectorStructAt 
	# fcolor : PackedColorArray 

	# GenFieldDebug for: 'fcolor'
	#FieldDef {
	# Definition Base Class
	#  name = fcolor
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 28
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Color
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 3
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ fvector2 ]================]
	func fvector2_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FVECTOR2 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fvector2() -> PackedVector2Array:
		var array_start : int = get_field_start( vtable.VT_FVECTOR2 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedVector2Array
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Vector2( array_start + i * 8)
		return array

	# TODO GenFieldVectorStructAt 
	# fvector2 : PackedVector2Array 

	# GenFieldDebug for: 'fvector2'
	#FieldDef {
	# Definition Base Class
	#  name = fvector2
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 30
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Vector2
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 9
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ fvector3 ]================]
	func fvector3_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FVECTOR3 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fvector3() -> PackedVector3Array:
		var array_start : int = get_field_start( vtable.VT_FVECTOR3 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedVector3Array
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Vector3( array_start + i * 12)
		return array

	# TODO GenFieldVectorStructAt 
	# fvector3 : PackedVector3Array 

	# GenFieldDebug for: 'fvector3'
	#FieldDef {
	# Definition Base Class
	#  name = fvector3
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 32
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Vector3
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 13
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ fvector4 ]================]
	func fvector4_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FVECTOR4 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fvector4() -> PackedVector4Array:
		var array_start : int = get_field_start( vtable.VT_FVECTOR4 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedVector4Array
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Vector4( array_start + i * 16)
		return array

	# TODO GenFieldVectorStructAt 
	# fvector4 : PackedVector4Array 

	# GenFieldDebug for: 'fvector4'
	#FieldDef {
	# Definition Base Class
	#  name = fvector4
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 34
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Vector4
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 5
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ faabb ]================]
	func faabb_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FAABB )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func faabb() -> Array[AABB]:
		var array_start : int = get_field_start( vtable.VT_FAABB )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[AABB]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_AABB( array_start + i * 24)
		return array

	# TODO GenFieldVectorStructAt 
	# faabb : Array[AABB] 

	# GenFieldDebug for: 'faabb'
	#FieldDef {
	# Definition Base Class
	#  name = faabb
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 36
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = AABB
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 3
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ fbasis ]================]
	func fbasis_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FBASIS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fbasis() -> Array[Basis]:
		var array_start : int = get_field_start( vtable.VT_FBASIS )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[Basis]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Basis( array_start + i * 36)
		return array

	# TODO GenFieldVectorStructAt 
	# fbasis : Array[Basis] 

	# GenFieldDebug for: 'fbasis'
	#FieldDef {
	# Definition Base Class
	#  name = fbasis
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 38
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Basis
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 5
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ fplane ]================]
	func fplane_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FPLANE )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fplane() -> Array[Plane]:
		var array_start : int = get_field_start( vtable.VT_FPLANE )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[Plane]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Plane( array_start + i * 16)
		return array

	# TODO GenFieldVectorStructAt 
	# fplane : Array[Plane] 

	# GenFieldDebug for: 'fplane'
	#FieldDef {
	# Definition Base Class
	#  name = fplane
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 40
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Plane
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 3
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ fprojection ]================]
	func fprojection_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FPROJECTION )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fprojection() -> Array[Projection]:
		var array_start : int = get_field_start( vtable.VT_FPROJECTION )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[Projection]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Projection( array_start + i * 64)
		return array

	# TODO GenFieldVectorStructAt 
	# fprojection : Array[Projection] 

	# GenFieldDebug for: 'fprojection'
	#FieldDef {
	# Definition Base Class
	#  name = fprojection
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 42
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Projection
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 3
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ fquaternion ]================]
	func fquaternion_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FQUATERNION )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fquaternion() -> Array[Quaternion]:
		var array_start : int = get_field_start( vtable.VT_FQUATERNION )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[Quaternion]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Quaternion( array_start + i * 16)
		return array

	# TODO GenFieldVectorStructAt 
	# fquaternion : Array[Quaternion] 

	# GenFieldDebug for: 'fquaternion'
	#FieldDef {
	# Definition Base Class
	#  name = fquaternion
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 44
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Quaternion
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 3
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ frect2 ]================]
	func frect2_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FRECT2 )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func frect2() -> Array[Rect2]:
		var array_start : int = get_field_start( vtable.VT_FRECT2 )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[Rect2]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Rect2( array_start + i * 16)
		return array

	# TODO GenFieldVectorStructAt 
	# frect2 : Array[Rect2] 

	# GenFieldDebug for: 'frect2'
	#FieldDef {
	# Definition Base Class
	#  name = frect2
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 46
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Rect2
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 3
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ frect2i ]================]
	func frect2i_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FRECT2I )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func frect2i() -> Array[Rect2i]:
		var array_start : int = get_field_start( vtable.VT_FRECT2I )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[Rect2i]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Rect2i( array_start + i * 16)
		return array

	# TODO GenFieldVectorStructAt 
	# frect2i : Array[Rect2i] 

	# GenFieldDebug for: 'frect2i'
	#FieldDef {
	# Definition Base Class
	#  name = frect2i
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 48
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Rect2i
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 3
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ ftransform2d ]================]
	func ftransform2d_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FTRANSFORM2D )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func ftransform2d() -> Array[Transform2D]:
		var array_start : int = get_field_start( vtable.VT_FTRANSFORM2D )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[Transform2D]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Transform2D( array_start + i * 24)
		return array

	# TODO GenFieldVectorStructAt 
	# ftransform2d : Array[Transform2D] 

	# GenFieldDebug for: 'ftransform2d'
	#FieldDef {
	# Definition Base Class
	#  name = ftransform2d
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 50
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Transform2D
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 3
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ ftransform3d ]================]
	func ftransform3d_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FTRANSFORM3D )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func ftransform3d() -> Array[Transform3D]:
		var array_start : int = get_field_start( vtable.VT_FTRANSFORM3D )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[Transform3D]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Transform3D( array_start + i * 48)
		return array

	# TODO GenFieldVectorStructAt 
	# ftransform3d : Array[Transform3D] 

	# GenFieldDebug for: 'ftransform3d'
	#FieldDef {
	# Definition Base Class
	#  name = ftransform3d
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 52
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Transform3D
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 3
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ fvector2i ]================]
	func fvector2i_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FVECTOR2I )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fvector2i() -> Array[Vector2i]:
		var array_start : int = get_field_start( vtable.VT_FVECTOR2I )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[Vector2i]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Vector2i( array_start + i * 8)
		return array

	# TODO GenFieldVectorStructAt 
	# fvector2i : Array[Vector2i] 

	# GenFieldDebug for: 'fvector2i'
	#FieldDef {
	# Definition Base Class
	#  name = fvector2i
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 54
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Vector2i
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 7
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ fvector3i ]================]
	func fvector3i_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FVECTOR3I )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fvector3i() -> Array[Vector3i]:
		var array_start : int = get_field_start( vtable.VT_FVECTOR3I )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[Vector3i]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Vector3i( array_start + i * 12)
		return array

	# TODO GenFieldVectorStructAt 
	# fvector3i : Array[Vector3i] 

	# GenFieldDebug for: 'fvector3i'
	#FieldDef {
	# Definition Base Class
	#  name = fvector3i
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 56
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Vector3i
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 3
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	# [================[ fvector4i ]================]
	func fvector4i_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FVECTOR4I )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func fvector4i() -> Array[Vector4i]:
		var array_start : int = get_field_start( vtable.VT_FVECTOR4I )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[Vector4i]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Vector4i( array_start + i * 16)
		return array

	# TODO GenFieldVectorStructAt 
	# fvector4i : Array[Vector4i] 

	# GenFieldDebug for: 'fvector4i'
	#FieldDef {
	# Definition Base Class
	#  name = fvector4i
	#  file = ./tests/gd_arrays/array_types.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = false
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 1
	#  declaration_file = NULL
	#  ---- 
	#  deprecated = false
	#  key = false
	#  shared = false
	#  native_inline = false
	#  flexbuffer = false
	#  offset64 = false
	#  IsScalar() = false
	#}
	#FieldDef.Value {
	#  constant: 0
	#  offset: 58
	#}
	#FieldDef.Value.Type {
	#  base_type: 
	#  element: 
	#  struct_def: exists
	#  enum_def: <null>
	#  fixed_length: 0
	#  IsStruct() = false
	#  IsArray() = false
	#  IsIncompleteStruct: false
	#  IsUnion() = false
	#  IsUnionType() = false
	#  IsSeries() = true
	#  IsVector() = true
	#  IsVectorOfTable() = false
	#  IsVectorOfStruct: true
	#  IsArray() = false
	#  IsString() = false
	#  IsTable() = false
	#  IsEnum() = false
	#}
	#FieldDef.Value.Type.struct_def = {
	# Definition Base Class
	#  name = Vector4i
	#  file = addons/gdflatbuffers/godot.fbs
	#  doc_comment = ?
	#  attributes = ??
	#  generated = true
	#  defined_namespace = 
	#  serialized_location = 0
	#  index = -1
	#  refcount = 3
	#  declaration_file = //../../addons/gdflatbuffers/godot.fbs
	#  ---- 
	#}
	func debug() -> Dictionary:
		var d : Dictionary = {}
		d['buffer_size'] = bytes.size()
		d['start'] = start
		d['vtable_offset'] = bytes.decode_s32( start )
		d['vtable_start'] = d.start - d.vtable_offset
		d['vtable'] = Dictionary()
		d.vtable['vtable_bytes'] = bytes.decode_u16( d.vtable_start )
		d.vtable['table_size'] = bytes.decode_u16( d.vtable_start + 2 )

		for i : int in ((d.vtable.vtable_bytes / 2) - 2):
			var keys : Array = vtable.keys()
			var offsets : Array = vtable.values()
			d.vtable[keys[i]] = bytes.decode_u16( d.vtable_start + offsets[i] )

		# fbool:Array 
		var fbool_dict : Dictionary = {'type':'Array'}
		fbool_dict['offset'] = get_field_offset( vtable.VT_FBOOL )
		if fbool_is_present():
			fbool_dict['type'] = 'Array of bool'
			fbool_dict['start'] = get_field_start( vtable.VT_FBOOL )
			fbool_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FBOOL ) )
			fbool_dict['value'] = fbool()

		d['fbool'] = fbool_dict
		# fint8:Array 
		var fint8_dict : Dictionary = {'type':'Array'}
		fint8_dict['offset'] = get_field_offset( vtable.VT_FINT8 )
		if fint8_is_present():
			fint8_dict['type'] = 'Array of byte'
			fint8_dict['start'] = get_field_start( vtable.VT_FINT8 )
			fint8_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FINT8 ) )
			fint8_dict['value'] = fint8()

		d['fint8'] = fint8_dict
		# fint16:Array 
		var fint16_dict : Dictionary = {'type':'Array'}
		fint16_dict['offset'] = get_field_offset( vtable.VT_FINT16 )
		if fint16_is_present():
			fint16_dict['type'] = 'Array of short'
			fint16_dict['start'] = get_field_start( vtable.VT_FINT16 )
			fint16_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FINT16 ) )
			fint16_dict['value'] = fint16()

		d['fint16'] = fint16_dict
		# fuint16:Array 
		var fuint16_dict : Dictionary = {'type':'Array'}
		fuint16_dict['offset'] = get_field_offset( vtable.VT_FUINT16 )
		if fuint16_is_present():
			fuint16_dict['type'] = 'Array of ushort'
			fuint16_dict['start'] = get_field_start( vtable.VT_FUINT16 )
			fuint16_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FUINT16 ) )
			fuint16_dict['value'] = fuint16()

		d['fuint16'] = fuint16_dict
		# fuint32:Array 
		var fuint32_dict : Dictionary = {'type':'Array'}
		fuint32_dict['offset'] = get_field_offset( vtable.VT_FUINT32 )
		if fuint32_is_present():
			fuint32_dict['type'] = 'Array of uint'
			fuint32_dict['start'] = get_field_start( vtable.VT_FUINT32 )
			fuint32_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FUINT32 ) )
			fuint32_dict['value'] = fuint32()

		d['fuint32'] = fuint32_dict
		# fint64:PackedInt64Array 
		var fint64_dict : Dictionary = {'type':'PackedInt64Array'}
		fint64_dict['offset'] = get_field_offset( vtable.VT_FINT64 )
		if fint64_is_present():
			fint64_dict['type'] = 'PackedInt64Array of long'
			fint64_dict['start'] = get_field_start( vtable.VT_FINT64 )
			fint64_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FINT64 ) )
			fint64_dict['value'] = fint64()

		d['fint64'] = fint64_dict
		# fuint8:PackedByteArray 
		var fuint8_dict : Dictionary = {'type':'PackedByteArray'}
		fuint8_dict['offset'] = get_field_offset( vtable.VT_FUINT8 )
		if fuint8_is_present():
			fuint8_dict['type'] = 'PackedByteArray of ubyte'
			fuint8_dict['start'] = get_field_start( vtable.VT_FUINT8 )
			fuint8_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FUINT8 ) )
			fuint8_dict['value'] = fuint8()

		d['fuint8'] = fuint8_dict
		# fint32:PackedInt32Array 
		var fint32_dict : Dictionary = {'type':'PackedInt32Array'}
		fint32_dict['offset'] = get_field_offset( vtable.VT_FINT32 )
		if fint32_is_present():
			fint32_dict['type'] = 'PackedInt32Array of int'
			fint32_dict['start'] = get_field_start( vtable.VT_FINT32 )
			fint32_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FINT32 ) )
			fint32_dict['value'] = fint32()

		d['fint32'] = fint32_dict
		# fuint64:Array 
		var fuint64_dict : Dictionary = {'type':'Array'}
		fuint64_dict['offset'] = get_field_offset( vtable.VT_FUINT64 )
		if fuint64_is_present():
			fuint64_dict['type'] = 'Array of ulong'
			fuint64_dict['start'] = get_field_start( vtable.VT_FUINT64 )
			fuint64_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FUINT64 ) )
			fuint64_dict['value'] = fuint64()

		d['fuint64'] = fuint64_dict
		# ffloat32:PackedFloat32Array 
		var ffloat32_dict : Dictionary = {'type':'PackedFloat32Array'}
		ffloat32_dict['offset'] = get_field_offset( vtable.VT_FFLOAT32 )
		if ffloat32_is_present():
			ffloat32_dict['type'] = 'PackedFloat32Array of float'
			ffloat32_dict['start'] = get_field_start( vtable.VT_FFLOAT32 )
			ffloat32_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FFLOAT32 ) )
			ffloat32_dict['value'] = ffloat32()

		d['ffloat32'] = ffloat32_dict
		# ffloat64:PackedFloat64Array 
		var ffloat64_dict : Dictionary = {'type':'PackedFloat64Array'}
		ffloat64_dict['offset'] = get_field_offset( vtable.VT_FFLOAT64 )
		if ffloat64_is_present():
			ffloat64_dict['type'] = 'PackedFloat64Array of double'
			ffloat64_dict['start'] = get_field_start( vtable.VT_FFLOAT64 )
			ffloat64_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FFLOAT64 ) )
			ffloat64_dict['value'] = ffloat64()

		d['ffloat64'] = ffloat64_dict
		# fstring:PackedStringArray 
		var fstring_dict : Dictionary = {'type':'PackedStringArray'}
		fstring_dict['offset'] = get_field_offset( vtable.VT_FSTRING )
		if fstring_is_present():
			fstring_dict['type'] = 'PackedStringArray of string'
			fstring_dict['start'] = get_field_start( vtable.VT_FSTRING )
			fstring_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FSTRING ) )
			fstring_dict['value'] = fstring()

		d['fstring'] = fstring_dict
		# fcolor:Array 
		var fcolor_dict : Dictionary = {'type':'Array'}
		fcolor_dict['offset'] = get_field_offset( vtable.VT_FCOLOR )
		if fcolor_is_present():
			fcolor_dict['type'] = 'Array of '
			fcolor_dict['start'] = get_field_start( vtable.VT_FCOLOR )
			fcolor_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FCOLOR ) )
			fcolor_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['fcolor'] = fcolor_dict
		# fvector2:Array 
		var fvector2_dict : Dictionary = {'type':'Array'}
		fvector2_dict['offset'] = get_field_offset( vtable.VT_FVECTOR2 )
		if fvector2_is_present():
			fvector2_dict['type'] = 'Array of '
			fvector2_dict['start'] = get_field_start( vtable.VT_FVECTOR2 )
			fvector2_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FVECTOR2 ) )
			fvector2_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['fvector2'] = fvector2_dict
		# fvector3:Array 
		var fvector3_dict : Dictionary = {'type':'Array'}
		fvector3_dict['offset'] = get_field_offset( vtable.VT_FVECTOR3 )
		if fvector3_is_present():
			fvector3_dict['type'] = 'Array of '
			fvector3_dict['start'] = get_field_start( vtable.VT_FVECTOR3 )
			fvector3_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FVECTOR3 ) )
			fvector3_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['fvector3'] = fvector3_dict
		# fvector4:Array 
		var fvector4_dict : Dictionary = {'type':'Array'}
		fvector4_dict['offset'] = get_field_offset( vtable.VT_FVECTOR4 )
		if fvector4_is_present():
			fvector4_dict['type'] = 'Array of '
			fvector4_dict['start'] = get_field_start( vtable.VT_FVECTOR4 )
			fvector4_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FVECTOR4 ) )
			fvector4_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['fvector4'] = fvector4_dict
		# faabb:Array 
		var faabb_dict : Dictionary = {'type':'Array'}
		faabb_dict['offset'] = get_field_offset( vtable.VT_FAABB )
		if faabb_is_present():
			faabb_dict['type'] = 'Array of '
			faabb_dict['start'] = get_field_start( vtable.VT_FAABB )
			faabb_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FAABB ) )
			faabb_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['faabb'] = faabb_dict
		# fbasis:Array 
		var fbasis_dict : Dictionary = {'type':'Array'}
		fbasis_dict['offset'] = get_field_offset( vtable.VT_FBASIS )
		if fbasis_is_present():
			fbasis_dict['type'] = 'Array of '
			fbasis_dict['start'] = get_field_start( vtable.VT_FBASIS )
			fbasis_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FBASIS ) )
			fbasis_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['fbasis'] = fbasis_dict
		# fplane:Array 
		var fplane_dict : Dictionary = {'type':'Array'}
		fplane_dict['offset'] = get_field_offset( vtable.VT_FPLANE )
		if fplane_is_present():
			fplane_dict['type'] = 'Array of '
			fplane_dict['start'] = get_field_start( vtable.VT_FPLANE )
			fplane_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FPLANE ) )
			fplane_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['fplane'] = fplane_dict
		# fprojection:Array 
		var fprojection_dict : Dictionary = {'type':'Array'}
		fprojection_dict['offset'] = get_field_offset( vtable.VT_FPROJECTION )
		if fprojection_is_present():
			fprojection_dict['type'] = 'Array of '
			fprojection_dict['start'] = get_field_start( vtable.VT_FPROJECTION )
			fprojection_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FPROJECTION ) )
			fprojection_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['fprojection'] = fprojection_dict
		# fquaternion:Array 
		var fquaternion_dict : Dictionary = {'type':'Array'}
		fquaternion_dict['offset'] = get_field_offset( vtable.VT_FQUATERNION )
		if fquaternion_is_present():
			fquaternion_dict['type'] = 'Array of '
			fquaternion_dict['start'] = get_field_start( vtable.VT_FQUATERNION )
			fquaternion_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FQUATERNION ) )
			fquaternion_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['fquaternion'] = fquaternion_dict
		# frect2:Array 
		var frect2_dict : Dictionary = {'type':'Array'}
		frect2_dict['offset'] = get_field_offset( vtable.VT_FRECT2 )
		if frect2_is_present():
			frect2_dict['type'] = 'Array of '
			frect2_dict['start'] = get_field_start( vtable.VT_FRECT2 )
			frect2_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FRECT2 ) )
			frect2_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['frect2'] = frect2_dict
		# frect2i:Array 
		var frect2i_dict : Dictionary = {'type':'Array'}
		frect2i_dict['offset'] = get_field_offset( vtable.VT_FRECT2I )
		if frect2i_is_present():
			frect2i_dict['type'] = 'Array of '
			frect2i_dict['start'] = get_field_start( vtable.VT_FRECT2I )
			frect2i_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FRECT2I ) )
			frect2i_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['frect2i'] = frect2i_dict
		# ftransform2d:Array 
		var ftransform2d_dict : Dictionary = {'type':'Array'}
		ftransform2d_dict['offset'] = get_field_offset( vtable.VT_FTRANSFORM2D )
		if ftransform2d_is_present():
			ftransform2d_dict['type'] = 'Array of '
			ftransform2d_dict['start'] = get_field_start( vtable.VT_FTRANSFORM2D )
			ftransform2d_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FTRANSFORM2D ) )
			ftransform2d_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['ftransform2d'] = ftransform2d_dict
		# ftransform3d:Array 
		var ftransform3d_dict : Dictionary = {'type':'Array'}
		ftransform3d_dict['offset'] = get_field_offset( vtable.VT_FTRANSFORM3D )
		if ftransform3d_is_present():
			ftransform3d_dict['type'] = 'Array of '
			ftransform3d_dict['start'] = get_field_start( vtable.VT_FTRANSFORM3D )
			ftransform3d_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FTRANSFORM3D ) )
			ftransform3d_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['ftransform3d'] = ftransform3d_dict
		# fvector2i:Array 
		var fvector2i_dict : Dictionary = {'type':'Array'}
		fvector2i_dict['offset'] = get_field_offset( vtable.VT_FVECTOR2I )
		if fvector2i_is_present():
			fvector2i_dict['type'] = 'Array of '
			fvector2i_dict['start'] = get_field_start( vtable.VT_FVECTOR2I )
			fvector2i_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FVECTOR2I ) )
			fvector2i_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['fvector2i'] = fvector2i_dict
		# fvector3i:Array 
		var fvector3i_dict : Dictionary = {'type':'Array'}
		fvector3i_dict['offset'] = get_field_offset( vtable.VT_FVECTOR3I )
		if fvector3i_is_present():
			fvector3i_dict['type'] = 'Array of '
			fvector3i_dict['start'] = get_field_start( vtable.VT_FVECTOR3I )
			fvector3i_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FVECTOR3I ) )
			fvector3i_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['fvector3i'] = fvector3i_dict
		# fvector4i:Array 
		var fvector4i_dict : Dictionary = {'type':'Array'}
		fvector4i_dict['offset'] = get_field_offset( vtable.VT_FVECTOR4I )
		if fvector4i_is_present():
			fvector4i_dict['type'] = 'Array of '
			fvector4i_dict['start'] = get_field_start( vtable.VT_FVECTOR4I )
			fvector4i_dict['size'] = bytes.decode_u32( get_field_start( vtable.VT_FVECTOR4I ) )
			fvector4i_dict['value'] = 'FIXME, Packed type arrays break what was here.'

		d['fvector4i'] = fvector4i_dict
		return d 


class TestTableBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ) -> void:
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_fbool( fbool_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FBOOL, fbool_offset )

	func add_fint8( fint8_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FINT8, fint8_offset )

	func add_fint16( fint16_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FINT16, fint16_offset )

	func add_fuint16( fuint16_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FUINT16, fuint16_offset )

	func add_fuint32( fuint32_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FUINT32, fuint32_offset )

	func add_fint64( fint64_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FINT64, fint64_offset )

	func add_fuint8( fuint8_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FUINT8, fuint8_offset )

	func add_fint32( fint32_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FINT32, fint32_offset )

	func add_fuint64( fuint64_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FUINT64, fuint64_offset )

	func add_ffloat32( ffloat32_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FFLOAT32, ffloat32_offset )

	func add_ffloat64( ffloat64_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FFLOAT64, ffloat64_offset )

	func add_fstring( fstring_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FSTRING, fstring_offset )

	func add_fcolor( fcolor_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FCOLOR, fcolor_offset )

	func add_fvector2( fvector2_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FVECTOR2, fvector2_offset )

	func add_fvector3( fvector3_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FVECTOR3, fvector3_offset )

	func add_fvector4( fvector4_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FVECTOR4, fvector4_offset )

	func add_faabb( faabb_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FAABB, faabb_offset )

	func add_fbasis( fbasis_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FBASIS, fbasis_offset )

	func add_fplane( fplane_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FPLANE, fplane_offset )

	func add_fprojection( fprojection_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FPROJECTION, fprojection_offset )

	func add_fquaternion( fquaternion_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FQUATERNION, fquaternion_offset )

	func add_frect2( frect2_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FRECT2, frect2_offset )

	func add_frect2i( frect2i_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FRECT2I, frect2i_offset )

	func add_ftransform2d( ftransform2d_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FTRANSFORM2D, ftransform2d_offset )

	func add_ftransform3d( ftransform3d_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FTRANSFORM3D, ftransform3d_offset )

	func add_fvector2i( fvector2i_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FVECTOR2I, fvector2i_offset )

	func add_fvector3i( fvector3i_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FVECTOR3I, fvector3i_offset )

	func add_fvector4i( fvector4i_offset : int ) -> void:
		fbb_.add_offset( TestTable.vtable.VT_FVECTOR4I, fvector4i_offset )

	func finish() -> int:
		var end : int = fbb_.end_table( start_ )
		var o : int = end
		return o;


static func create_TestTable( _fbb : FlatBufferBuilder,
		fbool : int,
		fint8 : int,
		fint16 : int,
		fuint16 : int,
		fuint32 : int,
		fint64 : int,
		fuint8 : int,
		fint32 : int,
		fuint64 : int,
		ffloat32 : int,
		ffloat64 : int,
		fstring : int,
		fcolor : int,
		fvector2 : int,
		fvector3 : int,
		fvector4 : int,
		faabb : int,
		fbasis : int,
		fplane : int,
		fprojection : int,
		fquaternion : int,
		frect2 : int,
		frect2i : int,
		ftransform2d : int,
		ftransform3d : int,
		fvector2i : int,
		fvector3i : int,
		fvector4i : int ) -> int :
	var builder : TestTableBuilder = TestTableBuilder.new( _fbb );
	builder.add_fvector4i( fvector4i );
	builder.add_fvector3i( fvector3i );
	builder.add_fvector2i( fvector2i );
	builder.add_ftransform3d( ftransform3d );
	builder.add_ftransform2d( ftransform2d );
	builder.add_frect2i( frect2i );
	builder.add_frect2( frect2 );
	builder.add_fquaternion( fquaternion );
	builder.add_fprojection( fprojection );
	builder.add_fplane( fplane );
	builder.add_fbasis( fbasis );
	builder.add_faabb( faabb );
	builder.add_fvector4( fvector4 );
	builder.add_fvector3( fvector3 );
	builder.add_fvector2( fvector2 );
	builder.add_fcolor( fcolor );
	builder.add_fstring( fstring );
	builder.add_ffloat64( ffloat64 );
	builder.add_ffloat32( ffloat32 );
	builder.add_fuint64( fuint64 );
	builder.add_fint32( fint32 );
	builder.add_fuint8( fuint8 );
	builder.add_fint64( fint64 );
	builder.add_fuint32( fuint32 );
	builder.add_fuint16( fuint16 );
	builder.add_fint16( fint16 );
	builder.add_fint8( fint8 );
	builder.add_fbool( fbool );
	return builder.finish();

static func get_TestTable( _bytes : PackedByteArray, _start : int ) -> TestTable:
	if _bytes.is_empty(): return null
	if _start == 0: _start = _bytes.decode_u32(0) # 0 always points to a buffer
	var new_TestTable : TestTable = TestTable.new()
	new_TestTable.start = _start
	new_TestTable.bytes = _bytes
	return new_TestTable


