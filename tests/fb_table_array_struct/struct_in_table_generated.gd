# automatically generated by the FlatBuffers compiler, do not modify

# To maintain reference counted PackedByteArray the gdextension type for data
# must be Variant, which triggers these two notices
@warning_ignore_start('unsafe_method_access')
@warning_ignore_start('unsafe_call_argument')

static func get_root( _bytes : PackedByteArray ) -> RootTable:
	return get_RootTable( _bytes, _bytes.decode_u32(0) )

static func create_Custom(
		_x : int,
		_y : float ) -> Custom :
	var val : Custom = Custom.new()
	val.y = _y;
	val.x = _x;
	return val

class Custom extends FlatBuffer:
	const size : int = 8

	func _init( bytes_ : PackedByteArray = [], start_ : int = 0) -> void:
		if bytes_.is_empty(): 
			bytes = PackedByteArray()
			bytes.resize( size )
		else:
			assert(start_ + size <= bytes_.size())
			bytes = bytes_; start = start_

	# [================[ x ]================]
	var x : int :
		get(): return bytes.decode_s32(start + 0)
		set(v): bytes.encode_s32(start + 0, v)

	# [================[ y ]================]
	var y : float :
		get(): return bytes.decode_float(start + 4)
		set(v): bytes.encode_float(start + 4, v)


class RootTable extends FlatBuffer:
	const _struct_in_table_schema = preload( 'struct_in_table_generated.gd' )

	enum vtable{
		VT_CUSTOM = 4,
		VT_BUILTIN = 6,
		VT_PACKABLE = 8,
		VT_TAIL = 10
	}

	func _init( bytes_ : PackedByteArray = [], start_ : int = 0) -> void:
		bytes = bytes_; start = start_

	# Presence Functions
	func custom_is_present() -> bool:
		return get_field_offset( vtable.VT_CUSTOM )

	func builtin_is_present() -> bool:
		return get_field_offset( vtable.VT_BUILTIN )

	func packable_is_present() -> bool:
		return get_field_offset( vtable.VT_PACKABLE )

	func tail_is_present() -> bool:
		return get_field_offset( vtable.VT_TAIL )

	# [================[ custom ]================]
	func custom_size() -> int:
		var array_start : int = get_field_start( vtable.VT_CUSTOM )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func custom() -> Array[Custom]:
		var array_start : int = get_field_start( vtable.VT_CUSTOM )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[Custom]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = _struct_in_table_schema.get_Custom(bytes, array_start + i * 8 )
		return array

	func custom_at( idx : int, into : Custom = null ) -> Custom:
		var field_start : int = get_field_start( vtable.VT_CUSTOM )
		var array_size : int = bytes.decode_u32( field_start )
		var array_start : int = field_start + 4
		assert(field_start, 'Field is not present in buffer' )
		assert( idx < array_size, 'index is out of bounds')
		var relative_offset : int = array_start + idx * 4
		var offset : int = relative_offset + bytes.decode_u32( relative_offset )
		if into:
			into.bytes = bytes
			into.start = relative_offset
			return into
		return _struct_in_table_schema.get_Custom( bytes, offset )

	# [================[ builtin ]================]
	func builtin_size() -> int:
		var array_start : int = get_field_start( vtable.VT_BUILTIN )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func builtin() -> Array[Vector3i]:
		var array_start : int = get_field_start( vtable.VT_BUILTIN )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array[Vector3i]
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Vector3i( array_start + i * 12)
		return array

	func builtin_at( idx : int ) -> Vector3i:
		var field_start : int = get_field_start( vtable.VT_BUILTIN )
		var array_size : int = bytes.decode_u32( field_start )
		var array_start : int = field_start + 4
		assert(field_start, 'Field is not present in buffer' )
		assert( idx < array_size, 'index is out of bounds')
		var relative_offset : int = array_start + idx * 4
		var offset : int = relative_offset + bytes.decode_u32( relative_offset )
		return decode_Vector3i( offset )

	# [================[ packable ]================]
	func packable_size() -> int:
		var array_start : int = get_field_start( vtable.VT_PACKABLE )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func packable() -> PackedColorArray:
		var array_start : int = get_field_start( vtable.VT_PACKABLE )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedColorArray
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = decode_Color( array_start + i * 16)
		return array

	func packable_at( idx : int ) -> Color:
		var field_start : int = get_field_start( vtable.VT_PACKABLE )
		var array_size : int = bytes.decode_u32( field_start )
		var array_start : int = field_start + 4
		assert(field_start, 'Field is not present in buffer' )
		assert( idx < array_size, 'index is out of bounds')
		var relative_offset : int = array_start + idx * 4
		var offset : int = relative_offset + bytes.decode_u32( relative_offset )
		return decode_Color( offset )

	# [================[ tail ]================]
	func tail() -> int:
		var foffset : int = get_field_offset( vtable.VT_TAIL )
		if not foffset: return -1
		return bytes.decode_s64( start + foffset )


class RootTableBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ) -> void:
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_custom( custom_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_CUSTOM, custom_offset )

	func add_builtin( builtin_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_BUILTIN, builtin_offset )

	func add_packable( packable_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_PACKABLE, packable_offset )

	func add_tail( tail : int ) -> void:
		fbb_.add_element_long_default( RootTable.vtable.VT_TAIL, tail, -1 )

	func finish() -> int:
		var end : int = fbb_.end_table( start_ )
		var o : int = end
		return o;


static func get_Custom( _bytes : PackedByteArray, _start : int = 0 ) -> Custom:
	assert(not _bytes.is_empty())
	return Custom.new(_bytes, _start)

static func get_RootTable( _bytes : PackedByteArray, _start : int = 0 ) -> RootTable:
	assert(not _bytes.is_empty())
	return RootTable.new(_bytes, _start)

static func create_RootTable( _fbb : FlatBufferBuilder,
		custom : int,
		builtin : int,
		packable : int,
		tail : int ) -> int :
	var builder : RootTableBuilder = RootTableBuilder.new( _fbb );
	builder.add_tail( tail );
	builder.add_packable( packable );
	builder.add_builtin( builtin );
	builder.add_custom( custom );
	return builder.finish();

