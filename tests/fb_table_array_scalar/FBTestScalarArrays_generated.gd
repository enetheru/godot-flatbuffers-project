# automatically generated by the FlatBuffers compiler, do not modify

# To maintain reference counted PackedByteArray the gdextension type for data
# must be Variant, which triggers these two notices
@warning_ignore_start('unsafe_method_access')
@warning_ignore_start('unsafe_call_argument')

static func get_root( _bytes : PackedByteArray ) -> RootTable:
	return get_RootTable( _bytes, _bytes.decode_u32(0) )

class RootTable extends FlatBuffer:
	enum vtable{
		VT_BYTES_ = 4,
		VT_UBYTES = 6,
		VT_SHORTS = 8,
		VT_USHORTS = 10,
		VT_INTS = 12,
		VT_UINTS = 14,
		VT_INT64S = 16,
		VT_UINT64S = 18,
		VT_FLOATS = 20,
		VT_DOUBLES = 22
	}

	func _init( bytes_ : PackedByteArray = [], start_ : int = 0) -> void:
		bytes = bytes_; start = start_

	# Presence Functions
	func bytes__is_present() -> bool:
		return get_field_offset( vtable.VT_BYTES_ )

	func ubytes_is_present() -> bool:
		return get_field_offset( vtable.VT_UBYTES )

	func shorts_is_present() -> bool:
		return get_field_offset( vtable.VT_SHORTS )

	func ushorts_is_present() -> bool:
		return get_field_offset( vtable.VT_USHORTS )

	func ints_is_present() -> bool:
		return get_field_offset( vtable.VT_INTS )

	func uints_is_present() -> bool:
		return get_field_offset( vtable.VT_UINTS )

	func int64s_is_present() -> bool:
		return get_field_offset( vtable.VT_INT64S )

	func uint64s_is_present() -> bool:
		return get_field_offset( vtable.VT_UINT64S )

	func floats_is_present() -> bool:
		return get_field_offset( vtable.VT_FLOATS )

	func doubles_is_present() -> bool:
		return get_field_offset( vtable.VT_DOUBLES )

	# [================[ bytes_ ]================]
	func bytes__size() -> int:
		var array_start : int = get_field_start( vtable.VT_BYTES_ )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func bytes_() -> Array:
		var array_start : int = get_field_start( vtable.VT_BYTES_ )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = bytes.decode_s8( array_start + i * 1)
		# To return packed array types, the scalar elements have to be of an appropriate type.
		return array

	func bytes__at( index : int ) -> bool:
		var array_start : int = get_field_start( vtable.VT_BYTES_ )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_s8( array_start + index * 1)

	# [================[ ubytes ]================]
	func ubytes_size() -> int:
		var array_start : int = get_field_start( vtable.VT_UBYTES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func ubytes() -> PackedByteArray:
		var array_start : int = get_field_start( vtable.VT_UBYTES )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		return bytes.slice( array_start, array_start + array_size )

	func ubytes_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_UBYTES )
		if not array_start: return 0
		array_start += 4
		return bytes[array_start + index]

	# [================[ shorts ]================]
	func shorts_size() -> int:
		var array_start : int = get_field_start( vtable.VT_SHORTS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func shorts() -> Array:
		var array_start : int = get_field_start( vtable.VT_SHORTS )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = bytes.decode_s16( array_start + i * 2)
		# To return packed array types, the scalar elements have to be of an appropriate type.
		return array

	func shorts_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_SHORTS )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_s16( array_start + index * 2)

	# [================[ ushorts ]================]
	func ushorts_size() -> int:
		var array_start : int = get_field_start( vtable.VT_USHORTS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func ushorts() -> Array:
		var array_start : int = get_field_start( vtable.VT_USHORTS )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = bytes.decode_u16( array_start + i * 2)
		# To return packed array types, the scalar elements have to be of an appropriate type.
		return array

	func ushorts_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_USHORTS )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_u16( array_start + index * 2)

	# [================[ ints ]================]
	func ints_size() -> int:
		var array_start : int = get_field_start( vtable.VT_INTS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func ints() -> PackedInt32Array:
		var array_start : int = get_field_start( vtable.VT_INTS )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array_end : int = array_start + array_size * 4
		return bytes.slice( array_start, array_end ).to_int32_array()

	func ints_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_INTS )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_s32( array_start + index * 4)

	# [================[ uints ]================]
	func uints_size() -> int:
		var array_start : int = get_field_start( vtable.VT_UINTS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func uints() -> Array:
		var array_start : int = get_field_start( vtable.VT_UINTS )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = bytes.decode_u32( array_start + i * 4)
		# To return packed array types, the scalar elements have to be of an appropriate type.
		return array

	func uints_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_UINTS )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_u32( array_start + index * 4)

	# [================[ int64s ]================]
	func int64s_size() -> int:
		var array_start : int = get_field_start( vtable.VT_INT64S )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func int64s() -> PackedInt64Array:
		var array_start : int = get_field_start( vtable.VT_INT64S )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array_end : int = array_start + array_size * 8
		return bytes.slice( array_start, array_end ).to_int64_array()

	func int64s_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_INT64S )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_s64( array_start + index * 8)

	# [================[ uint64s ]================]
	func uint64s_size() -> int:
		var array_start : int = get_field_start( vtable.VT_UINT64S )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func uint64s() -> Array:
		var array_start : int = get_field_start( vtable.VT_UINT64S )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : Array
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			array[i] = bytes.decode_u64( array_start + i * 8)
		# To return packed array types, the scalar elements have to be of an appropriate type.
		return array

	func uint64s_at( index : int ) -> int:
		var array_start : int = get_field_start( vtable.VT_UINT64S )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_u64( array_start + index * 8)

	# [================[ floats ]================]
	func floats_size() -> int:
		var array_start : int = get_field_start( vtable.VT_FLOATS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func floats() -> PackedFloat32Array:
		var array_start : int = get_field_start( vtable.VT_FLOATS )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array_end : int = array_start + array_size * 4
		return bytes.slice( array_start, array_end ).to_float32_array()

	func floats_at( index : int ) -> float:
		var array_start : int = get_field_start( vtable.VT_FLOATS )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_float( array_start + index * 4)

	# [================[ doubles ]================]
	func doubles_size() -> int:
		var array_start : int = get_field_start( vtable.VT_DOUBLES )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func doubles() -> PackedFloat64Array:
		var array_start : int = get_field_start( vtable.VT_DOUBLES )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array_end : int = array_start + array_size * 8
		return bytes.slice( array_start, array_end ).to_float64_array()

	func doubles_at( index : int ) -> float:
		var array_start : int = get_field_start( vtable.VT_DOUBLES )
		if not array_start: return 0
		array_start += 4
		return bytes.decode_double( array_start + index * 8)


class RootTableBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ) -> void:
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_bytes_( bytes__offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_BYTES_, bytes__offset )

	func add_ubytes( ubytes_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_UBYTES, ubytes_offset )

	func add_shorts( shorts_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_SHORTS, shorts_offset )

	func add_ushorts( ushorts_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_USHORTS, ushorts_offset )

	func add_ints( ints_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_INTS, ints_offset )

	func add_uints( uints_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_UINTS, uints_offset )

	func add_int64s( int64s_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_INT64S, int64s_offset )

	func add_uint64s( uint64s_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_UINT64S, uint64s_offset )

	func add_floats( floats_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_FLOATS, floats_offset )

	func add_doubles( doubles_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_DOUBLES, doubles_offset )

	func finish() -> int:
		var end : int = fbb_.end_table( start_ )
		var o : int = end
		return o;


static func get_RootTable( _bytes : PackedByteArray, _start : int = 0 ) -> RootTable:
	assert(not _bytes.is_empty())
	return RootTable.new(_bytes, _start)

static func create_RootTable( _fbb : FlatBufferBuilder,
		bytes_ : int,
		ubytes : int,
		shorts : int,
		ushorts : int,
		ints : int,
		uints : int,
		int64s : int,
		uint64s : int,
		floats : int,
		doubles : int ) -> int :
	var builder : RootTableBuilder = RootTableBuilder.new( _fbb );
	builder.add_doubles( doubles );
	builder.add_floats( floats );
	builder.add_uint64s( uint64s );
	builder.add_int64s( int64s );
	builder.add_uints( uints );
	builder.add_ints( ints );
	builder.add_ushorts( ushorts );
	builder.add_shorts( shorts );
	builder.add_ubytes( ubytes );
	builder.add_bytes_( bytes_ );
	return builder.finish();

