# automatically generated by the FlatBuffers compiler, do not modify

# To maintain reference counted PackedByteArray the gdextension type for data
# must be Variant, which triggers these two notices
@warning_ignore_start('unsafe_method_access')
@warning_ignore_start('unsafe_call_argument')

static func get_root( _bytes : PackedByteArray ) -> MyTable:
	return get_MyTable( _bytes, _bytes.decode_u32(0) )

class MyTable extends FlatBuffer:
	enum vtable{
		VT_FIRST_FIELD = 4
	}

	func _init( bytes_ : PackedByteArray = [], start_ : int = 0) -> void:
		bytes = bytes_; start = start_

	# Presence Functions
	func first_field_is_present() -> bool:
		return get_field_offset( vtable.VT_FIRST_FIELD )

	# [================[ first_field ]================]
	func first_field() -> int:
		var foffset : int = get_field_offset( vtable.VT_FIRST_FIELD )
		if not foffset: return 0
		return bytes.decode_s32( start + foffset )

	# TODO inplace-mutators
	# bool mutate_first_field(int32_t _first_field = 0) {
	# 	return SetField<int32_t>(VT_FIRST_FIELD, _first_field, 0);
	# }

	# TODO verification
	# template <bool B = false>
	# bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
	# 	return VerifyTableStart(verifier) &&
	# 		VerifyField<int32_t>(verifier, VT_FIRST_FIELD, 4) &&
	# 		verifier.EndTable();
	# }

	func verify(verifier:FlatBufferVerifier) -> bool:
		return verify_table_start(verifier) and \
			verify_field_u8(verifier, vtable.VT_FIRST_FIELD, 4) and \
			verifier.end_table();

# flatbuffers::Verifier verifier(flatbuf, length);
# if VerifyMyTableBuffer(verifier):
# 	pass



class MyTableBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ) -> void:
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_first_field( first_field : int ) -> void:
		fbb_.add_element_int_default( MyTable.vtable.VT_FIRST_FIELD, first_field, 0 )

	func finish() -> int:
		var end : int = fbb_.end_table( start_ )
		var o : int = end
		return o;


static func get_MyTable( _bytes : PackedByteArray, _start : int = 0 ) -> MyTable:
	assert(not _bytes.is_empty())
	return MyTable.new(_bytes, _start)


# TODO: size prefixed flatbuffers i do not yet suppot.
#inline const MyTable * _Nullable GetSizePrefixedMyTable(const void *buf) {
  #return ::flatbuffers::GetSizePrefixedRoot<MyTable>(buf);
#}

static func create_MyTable( _fbb : FlatBufferBuilder,
		first_field : int ) -> int :
	var builder : MyTableBuilder = MyTableBuilder.new( _fbb );
	builder.add_first_field( first_field );
	return builder.finish();


# FIXME, not sure what this is for
#struct MyTable::Traits {
  #using type = MyTable;
  #static auto constexpr Create = CreateMyTable;
#};


# TODO I think the only difference here is the lack of const on the buffer.
#inline MyTable *GetMutableMyTable(void *buf) {
  #return ::flatbuffers::GetMutableRoot<MyTable>(buf);
#}

# TODO, i do not yet support size prefixed tables.
#inline MyTable * _Nullable GetMutableSizePrefixedMyTable(void *buf) {
  #return ::flatbuffers::GetMutableSizePrefixedRoot<MyTable>(buf);
#}

# TODO verify functions
#template <bool B = false>
#inline bool VerifyMyTableBuffer(
	#::flatbuffers::VerifierTemplate<B> &verifier) {
  #return verifier.template VerifyBuffer<MyTable>(nullptr);
#}

# TODO, i do not yet support size prefixed tables.
#template <bool B = false>
#inline bool VerifySizePrefixedMyTableBuffer(
	#::flatbuffers::VerifierTemplate<B> &verifier) {
  #return verifier.template VerifySizePrefixedBuffer<MyTable>(nullptr);
#}

#inline void FinishMyTableBuffer(
	#::flatbuffers::FlatBufferBuilder &fbb,
	#::flatbuffers::Offset<MyTable> root) {
  #fbb.Finish(root);
#}

#inline void FinishSizePrefixedMyTableBuffer(
	#::flatbuffers::FlatBufferBuilder &fbb,
	#::flatbuffers::Offset<MyTable> root) {
  #fbb.FinishSizePrefixed(root);
#}
