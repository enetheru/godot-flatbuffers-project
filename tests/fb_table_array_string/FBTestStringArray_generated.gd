# automatically generated by the FlatBuffers compiler, do not modify

# To maintain reference counted PackedByteArray the gdextension type for data
# must be Variant, which triggers these two notices
@warning_ignore_start('unsafe_method_access')
@warning_ignore_start('unsafe_call_argument')

static func get_root( _bytes : PackedByteArray ) -> RootTable:
	return get_RootTable( _bytes, _bytes.decode_u32(0) )

class RootTable extends FlatBuffer:
	enum vtable{
		VT_MY_STRINGS = 4
	}

	func _init( bytes_ : PackedByteArray = [], start_ : int = 0) -> void:
		bytes = bytes_; start = start_

	# Presence Functions
	func my_strings_is_present() -> bool:
		return get_field_offset( vtable.VT_MY_STRINGS )

	# [================[ my_strings ]================]
	func my_strings_size() -> int:
		var array_start : int = get_field_start( vtable.VT_MY_STRINGS )
		if not array_start: return 0
		return bytes.decode_u32( array_start )

	func my_strings() -> PackedStringArray:
		var array_start : int = get_field_start( vtable.VT_MY_STRINGS )
		if not array_start: return []
		var array_size : int = bytes.decode_u32( array_start )
		array_start += 4
		var array : PackedStringArray
		if array.resize( array_size ) != OK: return []
		for i : int in array_size:
			var idx : int = array_start + i * 4
			var element_start : int = idx + bytes.decode_u32( idx )
			array[i] = decode_String( element_start )
		return array

	func my_strings_at( index : int ) -> String:
		var array_start : int = get_field_start( vtable.VT_MY_STRINGS )
		if not array_start: return ''
		array_start += 4
		var string_start : int = array_start + index * 4
		string_start += bytes.decode_u32( string_start )
		return decode_String( string_start )


class RootTableBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ) -> void:
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_my_strings( my_strings_offset : int ) -> void:
		fbb_.add_offset( RootTable.vtable.VT_MY_STRINGS, my_strings_offset )

	func finish() -> int:
		var end : int = fbb_.end_table( start_ )
		var o : int = end
		return o;


static func get_RootTable( _bytes : PackedByteArray, _start : int = 0 ) -> RootTable:
	assert(not _bytes.is_empty())
	return RootTable.new(_bytes, _start)

static func create_RootTable( _fbb : FlatBufferBuilder,
		my_strings : int ) -> int :
	var builder : RootTableBuilder = RootTableBuilder.new( _fbb );
	builder.add_my_strings( my_strings );
	return builder.finish();

