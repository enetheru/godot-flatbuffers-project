# automatically generated by the FlatBuffers compiler, do not modify

static func get_root( _bytes : PackedByteArray ) -> RootTable:
	return get_RootTable( _bytes, _bytes.decode_u32(0) )

static func get_CustomStruct( _bytes : PackedByteArray, _start : int ):
	return CustomStruct.new( _bytes, _start )

class CustomStruct extends FlatBuffer:
	func _init( bytes_ : PackedByteArray = [], start_ : int = 0) -> void:
		if bytes_.is_empty():
			var data = PackedByteArray()
			data.resize( 8 )
			bytes = data
			start = 0
		else: bytes = bytes_; start = start_

	# x : int
	var x : int :
		get(): return bytes.decode_s32(start + 0)
		set( v ):
			var data = bytes
			data.encode_s32(start + 0, v )
			bytes = data

	# y : float
	var y : float :
		get(): return bytes.decode_float(start + 4)
		set( v ):
			var data = bytes
			data.encode_float(start + 4, v )
			bytes = data


static func get_RootTable( _bytes : PackedByteArray, _start : int = 0 ) -> RootTable:
	if _bytes.is_empty(): return null
	var new_RootTable = RootTable.new()
	new_RootTable.start = _start
	new_RootTable.bytes = _bytes
	return new_RootTable


class RootTable extends FlatBuffer:
	const _script_parent : GDScript = preload("struct_types_generated.gd")

	enum vtable{
		VT_CUSTOM_STRUCT = 4,
		VT_FAABB = 6,
		VT_FBASIS = 8,
		VT_FCOLOR = 10,
		VT_FPLANE = 12,
		VT_FPROJECTION = 14,
		VT_FQUATERNION = 16,
		VT_FRECT2 = 18,
		VT_FRECT2I = 20,
		VT_FTRANSFORM2D = 22,
		VT_FTRANSFORM3D = 24,
		VT_FVECTOR2 = 26,
		VT_FVECTOR2I = 28,
		VT_FVECTOR3 = 30,
		VT_FVECTOR3I = 32,
		VT_FVECTOR4 = 34,
		VT_VECTOR4I = 36
	}

	func custom_struct_is_present() -> bool:
		return get_field_offset( vtable.VT_CUSTOM_STRUCT )

	func custom_struct() -> CustomStruct:
		var field_offset = get_field_offset( vtable.VT_CUSTOM_STRUCT )
		if not field_offset: return null
		return _script_parent.get_CustomStruct( bytes, start + field_offset )

	func faabb_is_present() -> bool:
		return get_field_offset( vtable.VT_FAABB )

	func faabb() -> AABB:
		return get_AABB( vtable.VT_FAABB )

	func fbasis_is_present() -> bool:
		return get_field_offset( vtable.VT_FBASIS )

	func fbasis() -> Basis:
		return get_Basis( vtable.VT_FBASIS )

	func fcolor_is_present() -> bool:
		return get_field_offset( vtable.VT_FCOLOR )

	func fcolor() -> Color:
		return get_Color( vtable.VT_FCOLOR )

	func fplane_is_present() -> bool:
		return get_field_offset( vtable.VT_FPLANE )

	func fplane() -> Plane:
		return get_Plane( vtable.VT_FPLANE )

	func fprojection_is_present() -> bool:
		return get_field_offset( vtable.VT_FPROJECTION )

	func fprojection() -> Projection:
		return get_Projection( vtable.VT_FPROJECTION )

	func fquaternion_is_present() -> bool:
		return get_field_offset( vtable.VT_FQUATERNION )

	func fquaternion() -> Quaternion:
		return get_Quaternion( vtable.VT_FQUATERNION )

	func frect2_is_present() -> bool:
		return get_field_offset( vtable.VT_FRECT2 )

	func frect2() -> Rect2:
		return get_Rect2( vtable.VT_FRECT2 )

	func frect2i_is_present() -> bool:
		return get_field_offset( vtable.VT_FRECT2I )

	func frect2i() -> Rect2i:
		return get_Rect2i( vtable.VT_FRECT2I )

	func ftransform2d_is_present() -> bool:
		return get_field_offset( vtable.VT_FTRANSFORM2D )

	func ftransform2d() -> Transform2D:
		return get_Transform2D( vtable.VT_FTRANSFORM2D )

	func ftransform3d_is_present() -> bool:
		return get_field_offset( vtable.VT_FTRANSFORM3D )

	func ftransform3d() -> Transform3D:
		return get_Transform3D( vtable.VT_FTRANSFORM3D )

	func fvector2_is_present() -> bool:
		return get_field_offset( vtable.VT_FVECTOR2 )

	func fvector2() -> Vector2:
		return get_Vector2( vtable.VT_FVECTOR2 )

	func fvector2i_is_present() -> bool:
		return get_field_offset( vtable.VT_FVECTOR2I )

	func fvector2i() -> Vector2i:
		return get_Vector2i( vtable.VT_FVECTOR2I )

	func fvector3_is_present() -> bool:
		return get_field_offset( vtable.VT_FVECTOR3 )

	func fvector3() -> Vector3:
		return get_Vector3( vtable.VT_FVECTOR3 )

	func fvector3i_is_present() -> bool:
		return get_field_offset( vtable.VT_FVECTOR3I )

	func fvector3i() -> Vector3i:
		return get_Vector3i( vtable.VT_FVECTOR3I )

	func fvector4_is_present() -> bool:
		return get_field_offset( vtable.VT_FVECTOR4 )

	func fvector4() -> Vector4:
		return get_Vector4( vtable.VT_FVECTOR4 )

	func vector4i_is_present() -> bool:
		return get_field_offset( vtable.VT_VECTOR4I )

	func vector4i() -> Vector4i:
		return get_Vector4i( vtable.VT_VECTOR4I )

	func debug() -> Dictionary:
		var d : Dictionary = {}
		d['buffer_size'] = bytes.size()
		d['start'] = start
		d['vtable_offset'] = bytes.decode_s32( start )
		d['vtable_start'] = d.start - d.vtable_offset
		d['vtable'] = Dictionary()
		d.vtable['vtable_bytes'] = bytes.decode_u16( d.vtable_start )
		d.vtable['table_size'] = bytes.decode_u16( d.vtable_start + 2 )

		for i in ((d.vtable.vtable_bytes / 2) - 2):
			var keys = vtable.keys()
			var offsets = vtable.values()
			d.vtable[keys[i]] = bytes.decode_u16( d.vtable_start + offsets[i] )

		# custom_struct:CustomStruct
		var custom_struct_dict = {'type':'CustomStruct'}
		custom_struct_dict['offset'] = get_field_offset( vtable.VT_CUSTOM_STRUCT )
		if custom_struct_is_present():
			custom_struct_dict['value'] = custom_struct()

		d['custom_struct'] = custom_struct_dict
		# faabb:AABB
		var faabb_dict = {'type':'AABB'}
		faabb_dict['offset'] = get_field_offset( vtable.VT_FAABB )
		if faabb_is_present():
			faabb_dict['value'] = faabb()

		d['faabb'] = faabb_dict
		# fbasis:Basis
		var fbasis_dict = {'type':'Basis'}
		fbasis_dict['offset'] = get_field_offset( vtable.VT_FBASIS )
		if fbasis_is_present():
			fbasis_dict['value'] = fbasis()

		d['fbasis'] = fbasis_dict
		# fcolor:Color
		var fcolor_dict = {'type':'Color'}
		fcolor_dict['offset'] = get_field_offset( vtable.VT_FCOLOR )
		if fcolor_is_present():
			fcolor_dict['value'] = fcolor()

		d['fcolor'] = fcolor_dict
		# fplane:Plane
		var fplane_dict = {'type':'Plane'}
		fplane_dict['offset'] = get_field_offset( vtable.VT_FPLANE )
		if fplane_is_present():
			fplane_dict['value'] = fplane()

		d['fplane'] = fplane_dict
		# fprojection:Projection
		var fprojection_dict = {'type':'Projection'}
		fprojection_dict['offset'] = get_field_offset( vtable.VT_FPROJECTION )
		if fprojection_is_present():
			fprojection_dict['value'] = fprojection()

		d['fprojection'] = fprojection_dict
		# fquaternion:Quaternion
		var fquaternion_dict = {'type':'Quaternion'}
		fquaternion_dict['offset'] = get_field_offset( vtable.VT_FQUATERNION )
		if fquaternion_is_present():
			fquaternion_dict['value'] = fquaternion()

		d['fquaternion'] = fquaternion_dict
		# frect2:Rect2
		var frect2_dict = {'type':'Rect2'}
		frect2_dict['offset'] = get_field_offset( vtable.VT_FRECT2 )
		if frect2_is_present():
			frect2_dict['value'] = frect2()

		d['frect2'] = frect2_dict
		# frect2i:Rect2i
		var frect2i_dict = {'type':'Rect2i'}
		frect2i_dict['offset'] = get_field_offset( vtable.VT_FRECT2I )
		if frect2i_is_present():
			frect2i_dict['value'] = frect2i()

		d['frect2i'] = frect2i_dict
		# ftransform2d:Transform2D
		var ftransform2d_dict = {'type':'Transform2D'}
		ftransform2d_dict['offset'] = get_field_offset( vtable.VT_FTRANSFORM2D )
		if ftransform2d_is_present():
			ftransform2d_dict['value'] = ftransform2d()

		d['ftransform2d'] = ftransform2d_dict
		# ftransform3d:Transform3D
		var ftransform3d_dict = {'type':'Transform3D'}
		ftransform3d_dict['offset'] = get_field_offset( vtable.VT_FTRANSFORM3D )
		if ftransform3d_is_present():
			ftransform3d_dict['value'] = ftransform3d()

		d['ftransform3d'] = ftransform3d_dict
		# fvector2:Vector2
		var fvector2_dict = {'type':'Vector2'}
		fvector2_dict['offset'] = get_field_offset( vtable.VT_FVECTOR2 )
		if fvector2_is_present():
			fvector2_dict['value'] = fvector2()

		d['fvector2'] = fvector2_dict
		# fvector2i:Vector2i
		var fvector2i_dict = {'type':'Vector2i'}
		fvector2i_dict['offset'] = get_field_offset( vtable.VT_FVECTOR2I )
		if fvector2i_is_present():
			fvector2i_dict['value'] = fvector2i()

		d['fvector2i'] = fvector2i_dict
		# fvector3:Vector3
		var fvector3_dict = {'type':'Vector3'}
		fvector3_dict['offset'] = get_field_offset( vtable.VT_FVECTOR3 )
		if fvector3_is_present():
			fvector3_dict['value'] = fvector3()

		d['fvector3'] = fvector3_dict
		# fvector3i:Vector3i
		var fvector3i_dict = {'type':'Vector3i'}
		fvector3i_dict['offset'] = get_field_offset( vtable.VT_FVECTOR3I )
		if fvector3i_is_present():
			fvector3i_dict['value'] = fvector3i()

		d['fvector3i'] = fvector3i_dict
		# fvector4:Vector4
		var fvector4_dict = {'type':'Vector4'}
		fvector4_dict['offset'] = get_field_offset( vtable.VT_FVECTOR4 )
		if fvector4_is_present():
			fvector4_dict['value'] = fvector4()

		d['fvector4'] = fvector4_dict
		# vector4i:Vector4i
		var vector4i_dict = {'type':'Vector4i'}
		vector4i_dict['offset'] = get_field_offset( vtable.VT_VECTOR4I )
		if vector4i_is_present():
			vector4i_dict['value'] = vector4i()

		d['vector4i'] = vector4i_dict
		return d


class RootTableBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ):
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_custom_struct( custom_struct : CustomStruct ) -> void:
		fbb_.add_bytes( RootTable.vtable.VT_CUSTOM_STRUCT, custom_struct.bytes )

	func add_faabb( faabb : AABB ) -> void:
		fbb_.add_AABB( RootTable.vtable.VT_FAABB, faabb )

	func add_fbasis( fbasis : Basis ) -> void:
		fbb_.add_Basis( RootTable.vtable.VT_FBASIS, fbasis )

	func add_fcolor( fcolor : Color ) -> void:
		fbb_.add_Color( RootTable.vtable.VT_FCOLOR, fcolor )

	func add_fplane( fplane : Plane ) -> void:
		fbb_.add_Plane( RootTable.vtable.VT_FPLANE, fplane )

	func add_fprojection( fprojection : Projection ) -> void:
		fbb_.add_Projection( RootTable.vtable.VT_FPROJECTION, fprojection )

	func add_fquaternion( fquaternion : Quaternion ) -> void:
		fbb_.add_Quaternion( RootTable.vtable.VT_FQUATERNION, fquaternion )

	func add_frect2( frect2 : Rect2 ) -> void:
		fbb_.add_Rect2( RootTable.vtable.VT_FRECT2, frect2 )

	func add_frect2i( frect2i : Rect2i ) -> void:
		fbb_.add_Rect2i( RootTable.vtable.VT_FRECT2I, frect2i )

	func add_ftransform2d( ftransform2d : Transform2D ) -> void:
		fbb_.add_Transform2D( RootTable.vtable.VT_FTRANSFORM2D, ftransform2d )

	func add_ftransform3d( ftransform3d : Transform3D ) -> void:
		fbb_.add_Transform3D( RootTable.vtable.VT_FTRANSFORM3D, ftransform3d )

	func add_fvector2( fvector2 : Vector2 ) -> void:
		fbb_.add_Vector2( RootTable.vtable.VT_FVECTOR2, fvector2 )

	func add_fvector2i( fvector2i : Vector2i ) -> void:
		fbb_.add_Vector2i( RootTable.vtable.VT_FVECTOR2I, fvector2i )

	func add_fvector3( fvector3 : Vector3 ) -> void:
		fbb_.add_Vector3( RootTable.vtable.VT_FVECTOR3, fvector3 )

	func add_fvector3i( fvector3i : Vector3i ) -> void:
		fbb_.add_Vector3i( RootTable.vtable.VT_FVECTOR3I, fvector3i )

	func add_fvector4( fvector4 : Vector4 ) -> void:
		fbb_.add_Vector4( RootTable.vtable.VT_FVECTOR4, fvector4 )

	func add_vector4i( vector4i : Vector4i ) -> void:
		fbb_.add_Vector4i( RootTable.vtable.VT_VECTOR4I, vector4i )

	func finish() -> int:
		var end = fbb_.end_table( start_ )
		var o = end
		return o;


static func create_RootTable( _fbb : FlatBufferBuilder,
		custom_struct : CustomStruct,
		faabb : AABB,
		fbasis : Basis,
		fcolor : Color,
		fplane : Plane,
		fprojection : Projection,
		fquaternion : Quaternion,
		frect2 : Rect2,
		frect2i : Rect2i,
		ftransform2d : Transform2D,
		ftransform3d : Transform3D,
		fvector2 : Vector2,
		fvector2i : Vector2i,
		fvector3 : Vector3,
		fvector3i : Vector3i,
		fvector4 : Vector4,
		vector4i : Vector4i ) -> int :
	var builder = RootTableBuilder.new( _fbb );
	builder.add_vector4i( vector4i );
	builder.add_fvector4( fvector4 );
	builder.add_fvector3i( fvector3i );
	builder.add_fvector3( fvector3 );
	builder.add_fvector2i( fvector2i );
	builder.add_fvector2( fvector2 );
	builder.add_ftransform3d( ftransform3d );
	builder.add_ftransform2d( ftransform2d );
	builder.add_frect2i( frect2i );
	builder.add_frect2( frect2 );
	builder.add_fquaternion( fquaternion );
	builder.add_fprojection( fprojection );
	builder.add_fplane( fplane );
	builder.add_fcolor( fcolor );
	builder.add_fbasis( fbasis );
	builder.add_faabb( faabb );
	builder.add_custom_struct( custom_struct );
	return builder.finish();
