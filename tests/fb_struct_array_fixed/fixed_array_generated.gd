# automatically generated by the FlatBuffers compiler, do not modify

# To maintain reference counted PackedByteArray the gdextension type for data
# must be Variant, which triggers these two notices
@warning_ignore_start('unsafe_method_access')
@warning_ignore_start('unsafe_call_argument')

static func get_root( _bytes : PackedByteArray ) -> RootTable:
	return get_RootTable( _bytes, _bytes.decode_u32(0) )

static func create_FAE(
		_ascalar : PackedInt32Array,
		_astruct : Array ) -> FAE :
	var val : FAE = FAE.new()
	val.astruct = _astruct;
	val.ascalar = _ascalar;
	return val

class FAE extends FlatBuffer:
	const size : int = 164

	func _init( bytes_ : PackedByteArray = [], start_ : int = 0) -> void:
		if bytes_.is_empty(): 
			bytes = PackedByteArray()
			bytes.resize( size )
		else:
			assert(start_ + size <= bytes_.size())
			bytes = bytes_; start = start_

	# [================[ ascalar ]================]
	var ascalar : PackedInt32Array :
		get = get_ascalar, set = set_ascalar

	func get_ascalar() -> PackedInt32Array:
		# TODO Scalar Type
		return bytes.slice(0, 0 + 32 * 4).to_int32_array()

	func set_ascalar( _v : PackedInt32Array ):
		# TODO Scalar Type
		pass

	func at_ascalar( idx : int ) -> int:
		assert( idx < 32)
		return bytes.decode_s32( bytes, 0 + idx * 4)

	# [================[ astruct ]================]
	var astruct : Array :
		get = get_astruct, set = set_astruct

	func get_astruct() -> Array:
		# TODO Builtin Type
		return []

	func set_astruct( _v : Array ):
		# TODO Builtin Type
		pass

	func at_astruct( idx : int ) -> Vector3i:
		assert( idx < 3)
		return bytes.decode_Vector3i( bytes, 128 + idx * 12)


class RootTable extends FlatBuffer:
	const _fixed_array_schema = preload( 'fixed_array_generated.gd' )

	enum vtable{
		VT_VALUE = 4
	}

	func _init( bytes_ : PackedByteArray = [], start_ : int = 0) -> void:
		bytes = bytes_; start = start_

	# Presence Functions
	func value_is_present() -> bool:
		return get_field_offset( vtable.VT_VALUE )

	# [================[ value ]================]
	func value() -> FAE:
		var field_offset : int = get_field_offset( vtable.VT_VALUE )
		if not field_offset: return null
		return _fixed_array_schema.get_FAE( bytes, start + field_offset )


class RootTableBuilder extends RefCounted:
	var fbb_: FlatBufferBuilder
	var start_ : int

	func _init( _fbb : FlatBufferBuilder ) -> void:
		fbb_ = _fbb
		start_ = _fbb.start_table()

	func add_value( value : FAE ) -> void:
		fbb_.add_bytes( RootTable.vtable.VT_VALUE, value.bytes ) 

	func finish() -> int:
		var end : int = fbb_.end_table( start_ )
		var o : int = end
		return o;


static func get_FAE( _bytes : PackedByteArray, _start : int = 0 ) -> FAE:
	assert(not _bytes.is_empty())
	return FAE.new(_bytes, _start)

static func get_RootTable( _bytes : PackedByteArray, _start : int = 0 ) -> RootTable:
	assert(not _bytes.is_empty())
	return RootTable.new(_bytes, _start)

static func create_RootTable( _fbb : FlatBufferBuilder,
		value : FAE ) -> int :
	var builder : RootTableBuilder = RootTableBuilder.new( _fbb );
	builder.add_value( value );
	return builder.finish();

